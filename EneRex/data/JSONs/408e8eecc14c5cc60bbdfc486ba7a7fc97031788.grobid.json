[
    {
        "basename": "408e8eecc14c5cc60bbdfc486ba7a7fc97031788.grobid",
        "fulltext": 24,
        "footnote_size": 2,
        "footnote_max": 2,
        "reference": 30,
        "authors": [
            "Dosovitskiy",
            "Springenberg",
            "Riedmiller",
            "Brox"
        ]
    },
    {
        "title": "Discriminative Unsupervised Feature Learning with Convolutional Neural Networks",
        "abstract": "Current methods for training convolutional neural networks depend on large amounts of labeled samples for supervised training. In this paper we present an approach for training a convolutional neural network using only unlabeled data. We train the network to discriminate between a set of surrogate classes. Each surrogate class is formed by applying a variety of transformations to a randomly sampled 'seed' image patch. We find that this simple feature learning algorithm is surprisingly successful when applied to visual object recognition. The feature representation learned by our algorithm achieves classification results matching or outperforming the current state-of-the-art for unsupervised learning on several popular datasets (STL-10, CIFAR-10, Caltech-101).",
        "Introduction": "Convolutional neural networks (CNNs) trained via backpropagation were recently shown to perform well on image classification tasks with millions of training images and thousands of categories  #b0  #b1 . While CNNs have been known to yield good results on supervised image classification tasks such as MNIST for a long time  #b2 , the feature representation learned by the recent networks achieves stateof-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101  #b1  #b3 , Caltech-256  #b1 , Caltech-UCSD birds dataset  #b3 , SUN-397 scene recognition database  #b3 ; detection on PASCAL VOC dataset  #b4 . The capability to generalize to new datasets makes supervised CNN training an attractive approach for generic visual feature learning.The downside of this approach is the need for expensive labeling, as the amount of required labeled samples grows quickly the larger the model gets. The large performance increase achieved by methods based on the work of Krizhevsky et al.  #b0  was only possible due to massive efforts on manually annotating millions of images. For this reason, unsupervised learning -although currently underperforming -remains an appealing paradigm, since it can make use of raw unlabeled images and videos. Furthermore, on vision tasks outside classification it is not even sure, if training based on object class labels is advantageous. For example, unsupervised feature learning is known to be beneficial for image restoration  #b5  and recent results show that it outperforms supervised feature learning also on descriptor matching  #b6 .In this work we combine the power of a discriminative objective with the major advantage of unsupervised feature learning: cheap data acquisition. We introduce a novel training procedure for convolutional neural networks that does not require any labeled data. It rather relies on an automatically generated surrogate task. The task is created by taking the idea of data augmentationwhich is commonly used in supervised learning -to the extreme. Starting with trivial surrogate classes consisting of one random image patch each, we augment the data by applying a random set of transformations to each patch. Then we train a CNN to classify these surrogate classes.The feature representation learned by the network is, by construction, discriminative and invariant to typical transformations. We confirm this both theoretically and empirically, showing that this approach matches or outperforms all previous unsupervised feature learning methods on the standard image classification benchmarks STL-10, CIFAR-10, and Caltech-101.",
        "Related Work": "Our approach is related to a large body of work on unsupervised learning of invariant features and training of convolutional neural networks.Convolutional training is commonly used in both supervised and unsupervised methods to utilize the invariance of image statistics to translations (e.g. LeCun et al.  #b2 , Kavukcuoglu et al.  #b7 , Krizhevsky et al.  #b0 ). Similar to our approach the current surge of successful methods employing convolutional neural networks for object recognition often rely on data augmentation to generate additional training samples for their classification objective (e.g. Krizhevsky et al.  #b0 , Zeiler and Fergus  #b1 ). While we share the architecture (a convolutional neural network) with these approaches, our method does not rely on any labeled training data.In unsupervised learning, several studies on learning invariant representations exist. Denoising autoencoders  #b8 , for example, learn features that are robust to noise by trying to reconstruct data from randomly perturbed input samples. Similarly, contractive autoencoders  #b9  penalize the sensitivity of the feature representation to small changes in the input. Zou et al.  #b10  learn invariant features from video by enforcing a temporal slowness constraint on the feature representation learned by a linear autoencoder. Sohn and Lee  #b11  and Hui  #b12  learn features invariant to local image transformations. In contrast to our discriminative approach, all these methods rely on directly modeling the input distribution and are typically hard to use for jointly training multiple layers of a CNN.The idea of learning features that are invariant to transformations has also been explored for supervised training of neural networks. The research most similar to ours is early work on tangent propagation  #b13  (and the related double backpropagation  #b14 ) which aims to learn invariance to small predefined transformations in a neural network by directly penalizing the derivative of the output with respect to the magnitude of the transformations. In contrast, our algorithm does not regularize the derivative explicitly. Thus it is less sensitive to the magnitude of the applied transformation. This work is also loosely related to the use of unlabeled data for regularizing supervised algorithms, for example self-training  #b15  or entropy regularization  #b16 . In contrast to these semi-supervised methods, our network training does not require any labeled data.Finally, the idea of creating an auxiliary task in order to learn a good data representation was used by Ahmed et al.  #b17 , Collobert et al.  #b18 .",
        "Creating Surrogate Training Data": "The input to the training procedure is a set of unlabeled images, which come from roughly the same distribution as the images to which we later aim to apply the learned features. We randomly sample N \u2208 [50, 32000] patches of size 32\u00d732 pixels from different images at varying positions and scales forming the initial training set X = {x 1 , . . . x N }. We are interested in patches containing objects or parts of objects, hence we sample only from regions containing considerable gradients.We define a family of transformations {T \u03b1 | \u03b1 \u2208 A} parameterized by vectors \u03b1 \u2208 A, where A is the set of all possible parameter vectors. Each transformation T \u03b1 is a composition of elementary transformations from the following list:\u2022 translation: vertical or horizontal translation by a distance within 0.2 of the patch size;\u2022 scaling: multiplication of the patch scale by a factor between 0.7 and 1.4;\u2022 rotation: rotation of the image by an angle up to 20 degrees; \u2022 contrast 1: multiply the projection of each patch pixel onto the principal components of the set of all pixels by a factor between 0.5 and 2 (factors are independent for each principal component and the same for all pixels within a patch);  \u2022 contrast 2: raise saturation and value (S and V components of the HSV color representation) of all pixels to a power between 0.25 and 4 (same for all pixels within a patch), multiply these values by a factor between 0.7 and 1.4, add to them a value between -0.1 and 0.1; \u2022 color: add a value between -0.1 and 0.1 to the hue (H component of the HSV color representation) of all pixels in the patch (the same value is used for all pixels within a patch).All numerical parameters of elementary transformations, when concatenated together, form a single parameter vector \u03b1. For each initial patch x i \u2208 X we sample K \u2208 [1, 300] random parameter vectors {\u03b1 1 i , . . . , \u03b1 K i } and apply the corresponding transformations T i = {T \u03b1 1 i , . . . , T \u03b1 K i } to the patch x i . This yields the set of its transformed versions S xi = T i x i = {T x i | T \u2208 T i }. Afterwards we subtract the mean of each pixel over the whole resulting dataset. We do not apply any other preprocessing. Exemplary patches sampled from the STL-10 unlabeled dataset are shown in Fig. 1. Examples of transformed versions of one patch are shown in Fig. 2 .",
        "Learning Algorithm": "Given the sets of transformed image patches, we declare each of these sets to be a class by assigning label i to the class S xi . We next train a CNN to discriminate between these surrogate classes. Formally, we minimize the following loss function:L(X) = xi\u2208X T \u2208Ti l(i, T x i ),(1)where l(i, T x i ) is the loss on the transformed sample T x i with (surrogate) true label i. We use a CNN with a softmax output layer and optimize the multinomial negative log likelihood of the network output, hence in our casel(i, T x i ) = M (e i , f (T x i )), M (y, f ) = -y, log f = - k y k log f k ,(2)where f (\u2022) denotes the function computing the values of the output layer of the CNN given the input data, and e i is the ith standard basis vector. We note that in the limit of an infinite number of transformations per surrogate class, the objective function (1) takes the formL(X) = xi\u2208X E \u03b1 [l(i, T \u03b1 x i )],(3)which we shall analyze in the next section.Intuitively, the classification problem described above serves to ensure that different input samples can be distinguished. At the same time, it enforces invariance to the specified transformations. In the following sections we provide a foundation for this intuition. We first present a formal analysis of the objective, separating it into a well defined classification problem and a regularizer that enforces invariance (resembling the analysis in Wager et al.  #b19 ). We then discuss the derived properties of this classification problem and compare it to common practices for unsupervised feature learning.",
        "Formal Analysis": "We denote by \u03b1 \u2208 A the random vector of transformation parameters, by g(x) the vector of activations of the second-to-last layer of the network when presented the input patch x, by W the matrix of the weights of the last network layer, by h(x) = Wg(x) the last layer activations before applying the softmax, and by f (x) = softmax (h(x)) the output of the network. By plugging in the definition of the softmax activation functionsoftmax (z) = exp(z)/ exp(z) 1(4)the objective function (3) with loss (2) takes the formxi\u2208X E \u03b1 -e i , h(T \u03b1 x i ) + log exp(h(T \u03b1 x i )) 1 .(5)Withg i = E \u03b1 [g(T \u03b1 x i )]being the average feature representation of transformed versions of the image patch x i we can rewrite Eq. ( 5) asxi\u2208X -e i , W g i + log exp(W g i ) 1 + xi\u2208X E \u03b1 [log exp(h(T \u03b1 x i )) 1 ] -log exp(W g i ) 1 .(6)The first sum is the objective function of a multinomial logistic regression problem with input-target pairs ( g i , e i ). This objective falls back to the transformation-free instance classification problemL(X) = xi\u2208X l(i, x i ) if g(x i ) = E \u03b1 [g(T \u03b1 x)].In general, this equality does not hold and thus the first sum enforces correct classification of the average representation E \u03b1 [g(T \u03b1 x i )] for a given input sample. For a truly invariant representation, however, the equality is achieved. Similarly, if we suppose that T \u03b1 x = x for \u03b1 = 0, that for small values of \u03b1 the feature representation g(T \u03b1 x i ) is approximately linear with respect to \u03b1 and that the random variable \u03b1 is centered, i.e. E \u03b1 [\u03b1] = 0,then g i = E \u03b1 [g(T \u03b1 x i )] \u2248 E \u03b1 [g(x i ) + \u2207 \u03b1 (g(T \u03b1 x i ))| \u03b1=0 \u03b1] = g(x i ).The second sum in Eq. ( 6) can be seen as a regularizer enforcing all h(T \u03b1 x i ) to be close to their average value, i.e., the feature representation is sought to be approximately invariant to the transformations T \u03b1 . To show this we use the convexity of the function log exp(\u2022) 1 and Jensen's inequality, which yields (proof in supplementary material)E \u03b1 [log exp(h(T \u03b1 x i )) 1 ] -log exp(W g i ) 1 \u2265 0.(7)If the feature representation is perfectly invariant, then h(T \u03b1 x i ) = W g i and inequality  #b11  turns to equality, meaning that the regularizer reaches its global minimum.",
        "Conceptual Comparison to Previous Unsupervised Learning Methods": "Suppose we want to unsupervisedly learn a feature representation useful for a recognition task, for example classification. The mapping from input images x to a feature representation g(x) should then satisfy two requirements: (1) there must be at least one feature that is similar for images of the same category y (invariance); (2) there must be at least one feature that is sufficiently different for images of different categories (ability to discriminate).Most unsupervised feature learning methods aim to learn such a representation by modeling the input distribution p(x). This is based on the assumption that a good model of p(x) contains information about the category distribution p(y|x). That is, if a representation is learned, from which a given sample can be reconstructed perfectly, then the representation is expected to also encode information about the category of the sample (ability to discriminate). Additionally, the learned representation should be invariant to variations in the samples that are irrelevant for the classification task, i.e., it should adhere to the manifold hypothesis (see e.g. Rifai et al.  #b20  for a recent discussion). Invariance is classically achieved by regularization of the latent representation, e.g., by enforcing sparsity  #b7  or robustness to noise  #b8 .In contrast, the discriminative objective in Eq. ( 1) does not directly model the input distribution p(x) but learns a representation that discriminates between input samples. The representation is not required to reconstruct the input, which is unnecessary in a recognition or matching task. This leaves more degrees of freedom to model the desired variability of a sample. As shown in our analysis (see Eq. ( 12)), we achieve partial invariance to transformations applied during surrogate data creation by forcing the representation g(T \u03b1 x i ) of the transformed image patch to be predictive of the surrogate label assigned to the original image patch x i .An assumption of our approach is that the transformations T \u03b1 do not change the identity of the image content. Imagine a task that mainly relies on color information, as differentiating black panthers from pumas. If we use a color transformation, we will force the network to be invariant to this change and cannot expect the extracted features to perform well in this task 1 .",
        "Experiments": "We report here two additional experiments studying influence of different aspects of the algorithm on the quality of the learned features. We also give the details on how we measure invariance of feature representations in Section 4.3.4 of the paper.",
        "Experimental Setup": "The datasets we test on differ in the number of classes (10 for CIFAR and STL, 101 for Caltech) and the number of samples per class. STL is especially well suited for unsupervised learning as it contains a large set of 100,000 unlabeled samples. In all experiments (except for the dataset transfer experiment in the supplementary material) we extracted surrogate training data from the unlabeled subset of STL-10. When testing on CIFAR-10, we resized the images from 32 \u00d7 32 pixels to 64 \u00d7 64 pixels so that the scale of depicted objects roughly matches the two other datasets.We worked with two network architectures. A \"small\" network was used to evaluate the influence of different components of the augmentation procedure on classification performance. It consists of two convolutional layers with 64 filters each followed by a fully connected layer with 128 neurons. This last layer is succeeded by a softmax layer, which serves as the network output. A \"large\" network, consisting of three convolutional layers with 64, 128 and 256 filters respectively followed by a fully connected layer with 512 neurons, was trained to compare our method to the state-ofthe-art. In both models all convolutional filters are connected to a 5 \u00d7 5 region of their input.2 \u00d7 2 max-pooling was performed after the first and second convolutional layers. Dropout  #b24  was applied to the fully connected layers. We trained the networks using an implementation based on Caffe  #b25 . Details on the training procedure, the hyperparameter settings, and an analysis of the performance depending on the network architecture is provided in the supplementary material.We applied the feature representation to images of arbitrary size by convolutionally computing the responses of all the network layers except the top softmax. To each feature map, we applied the pooling method that is commonly used on the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure on STL-10 and CIFAR-10 [27, 11, 28, 13];2) 3-layer spatial pyramid, i.e. max-pooling over the whole image as well as within 4 quadrants and within the cells of a 4 \u00d7 4 grid, resulting in 1 + 4 + 16 = 21 values per feature map, which is the standard on Caltech-101  #b28  #b10  #b29 . Finally, we trained a linear support vector machine (SVM) on the pooled features.On all datasets we used the standard training and test protocols. On STL-10 the SVM was trained on 10 pre-defined folds of the training data. We report the mean and standard deviation achieved on the fixed test set. For CIFAR-10 we report two results:  ",
        "Classification Results": "In Table 1 we compare our method to several unsupervised feature learning methods, including the current state-of-the-art on each dataset. We do not compare to supervised methods which use class labels for learning feature representations. Additionally we show the dimensionality of the feature vectors produced by each method before final pooling. The small network was trained on 8000 surrogate classes containing 150 samples each and the large one on 16000 classes with 100 samples each.The features extracted from the larger network match or outperform the best prior result on all datasets. This is despite the fact that the dimensionality of the feature vector is smaller than that of most other approaches and that the networks are trained on the STL-10 unlabeled dataset (i.e. they are used in a transfer learning manner when applied to CIFAR-10 and Caltech 101). The increase in performance is especially pronounced when only few labeled samples are available for training the SVM (as is the case for all the datasets except full CIFAR-10). This is in agreement with previous evidence that with increasing feature vector dimensionality and number of labeled samples, training an SVM typically becomes less dependent on the quality of the extracted features  #b26  #b12 .Remarkably, on STL-10 we achieve an accuracy of 72.8% \u00b1 0.4%, which is a large improvement over all previously reported results.",
        "Detailed Analysis": "Apart from the overall classification results, we studied the effect of three design choices in our approach and validate the invariance properties of the learned features. Additional experiments on the influence of the dataset, from which the 'seed' patches are sampled, can be found in the supplementary material. We used the \"small\" network in all experiments reported below.",
        "Number of Surrogate Classes": "We varied the number N of surrogate classes between 50 and 32000. As a sanity check, we also tried classification with random filters. The results are shown in Fig. 3.Clearly, the classification accuracy increases with the number of surrogate classes until it reaches an optimum for about 8000 surrogate classes after which it did not change or even decreased. This is to be expected: the larger the number of surrogate classes, the more likely it is to draw very similar or even identical samples, which are hard or impossible to discriminate. Few such cases are not detrimental to the classification performance, but as soon as such collisions dominate the set of surrogate labels, the discriminative loss is no longer reasonable. The classification problem becomes too difficult and adapting the network to the surrogate task no longer succeeds. To check the validity of this explanation we also plot in Fig. 3 the classification error on the validation set (taken from the surrogate data) computed after training the network. It rapidly grows as the number of surrogate classes increases. We also observed that the optimal number of surrogate classes increases with  the size of the network (not shown in the figure), but eventually saturates. This demonstrates the main limitation of our current approach of randomly sampling 'seed' patches: it does not scale to arbitrarily large amounts of unlabeled data. However, we do not see this as a fundamental restriction and discuss possible solutions in Section 5 .",
        "Number of Samples per Surrogate Class": "Fig. 4 shows the classification accuracy when the number K of training samples per surrogate class varies between 1 and 300. The performance improves with more samples per surrogate class and saturates at around 100 samples. This indicates that this amount is sufficient to approximate the formal objective from Eq. ( 3), hence further increasing the number of samples does not significantly change the optimization problem. On the other hand, if the number of samples is too small, there is insufficient data to learn the desired invariance properties. We varied the transformations used for creating the surrogate data to analyze their influence on the final classification performance. The set of 'seed' patches was fixed. The result is shown in Fig. 5. The value '0' corresponds to applying random compositions of all elementary transformations: scaling, rotation, translation, color variation, and contrast variation. Different columns of the plot show the difference in classification accuracy as we discarded some types of elementary transformations.",
        "Types of Transformations": "Several tendencies can be observed. First, rotation and scaling have only a minor impact on the performance, while translations, color variations and contrast variations are significantly more important. Secondly, the results on STL-10 and CIFAR-10 consistently show that spatial invariance and color-contrast invariance are approximately of equal importance for the classification performance. This indicates that variations in color and contrast, though often neglected, may also improve performance in a supervised learning scenario. Thirdly, on Caltech-101 color and contrast transformations are much more important compared to spatial transformations than on the two other datasets. This is not surprising, since Caltech-101 images are often well aligned, and this dataset bias makes spatial invariance less useful.",
        "Invariance Properties of the Learned Representation": "In a final experiment, we analyzed to which extent the representation learned by the network is invariant to the transformations applied during training. We randomly sampled 500 images from the STL-10 test set and applied a range of transformations (translation, rotation, contrast, color) to each image. To avoid empty regions beyond the image boundaries when applying spatial transformations, we cropped the central 64 \u00d7 64 pixel sub-patch from each 96 \u00d7 96 pixel image. We then applied two measures of invariance to these patches.First, as an explicit measure of invariance, we calculated the normalized Euclidean distance between normalized feature vectors of the original image patch and the transformed one  #b10  (see the supplementary material for details). The downside of this approach is that the distance between extracted features does not take into account how informative and discriminative they are.We therefore evaluated a second measure -classification performance depending on the magnitude of the transformation applied to the classified patches -which does not come with this problem. To compute the classification accuracy, we trained an SVM on the central 64 \u00d7 64 pixel patches from one fold of the STL-10 training set and measured classification performance on all transformed versions of 500 samples from the test set.The results of both experiments are shown in Fig. 6 . Due to space restrictions we show only few representative plots. Overall the experiment empirically confirms that our objective function leads to learning invariant features. Features in the third layer and the final pooled feature representation compare favorably to a HOG baseline (Fig. 6 (a)). Furthermore, adding stronger transformations in the surrogate training data leads to more invariant classification with respect to these transformations (Fig. 6 (b)-(d)). However, adding too much contrast variation may deteriorate classification performance (Fig. 6 (d)). One possible reason is that level of contrast can be a useful feature: for example, strong edges in an image are usually more important than weak ones.",
        "Discussion": "We have proposed a way to use a discriminative objective for unsupervised feature learning by training a CNN without class labels. The core idea is to generate a set of surrogate labels via data augmentation. The features learned by the network yield a large improvement in classification accuracy compared to features obtained with previous unsupervised methods. These results strongly indicate that a discriminative objective is superior to objectives previously used for unsupervised feature learning.One potential shortcoming of the proposed method is that in its current state it does not scale to arbitrarily large datasets. Two probable reasons for this are that (1) as the number of surrogate classes grows larger, many of them become similar, which contradicts the discriminative objective, and (2) the surrogate task we use is relatively simple and does not allow the network to learn invariance to complex variations, such as 3D viewpoint changes or inter-instance variation. We hypothesize that the presented approach could learn more powerful higher-level features, if the surrogate data were more diverse. This could be achieved by using additional weak supervision, for example, by means of video or a small number of labeled samples. Another possible way of obtaining richer surrogate training data and at the same time avoiding similar surrogate classes would be (unsupervised) merging of similar surrogate classes. We see these as interesting directions for future work.",
        "Details on Training Procedure": "We describe here in detail which network architectures we tried and explain the network training procedure.",
        "Network Architecture": "We tested various network architectures in combination with our training procedure. They are coded as follows: NcF stands for a convolutional layer with N filters of size F \u00d7 F pixels, Nf stands for a fully connected layer with N neurons. For example, 64c5-64c5-128f denotes a network with two convolutional layers containing 64 filters spanning 5 \u00d7 5 pixels each followed by a fully connected layer with 128 neurons. The last specified layer is always succeeded by a softmax layer, which serves as the network output. We applied 2 \u00d7 2 max-pooling to the outputs of the first and second convolutional layers.As stated in the paper we used a 64c5-64c5-128f architecture in our experiments to evaluate the influence of different components of the augmentation procedure (we refer to this architecture as the 'small' network). A large network, coded as 64c5-128c5-256c5-512f, was then used to achieve better classification performance.All considered networks contained rectified linear units in each layer but the softmax layer. Dropout was applied to the fully connected layer.",
        "Training the Networks": "We adopted the common practice of training the network with stochastic gradient descent with a fixed momentum of 0.9. We started with a learning rate of 0.01 and gradually decreased the learning rate during training. That is, we trained until there was no improvement in validation error, then decreased the learning rate by a factor of 3, and repeated this procedure until convergence.",
        "Influence of the Network Architecture on Classification Performance": "We perform an additional experiment to evaluate the influence of the network architecture on classification performance. The results of this experiment are shown in Table 2. All networks were trained using a surrogate training set containing either 8000 classes with 150 samples each or 16000 classes with 100 samples each (for larger networks). We vary the number of layers, layer sizes and filter sizes. Classification accuracy generally improves with the network size indicating that our classification problem scales well to relatively large networks without overfitting.",
        "Influence of the Dataset": "We applied our feature learning algorithm to images sampled from three datasets -STL-10 unlabeled dataset, CIFAR-10 and Caltech-101 -and evaluated the performance of the learned feature representations on classification tasks on these datasets. We used the \"small\" network (64c5-64c5-128f) for this experiment.We show first layer filters learned from the three datasets in Fig. 7. Note how filters qualitatively differ depending on the dataset they were trained on.Classification results are shown in Table 3. The best classification results for each dataset are obtained when training on the patches extracted from the dataset itself. However, the difference is not drastic, indicating that the learned features generalize well to other datasets. Table 2: Classification accuracy depending on the network architecture. The name coding is as follows: NcF stands for a convolutional layer with N filters of size F \u00d7 F pixels, Nf stands for a fully connected layer with N neurons. For example, 64c5-64c5-128f denotes a network with two convolutional layers containing 64 filters spanning 5 \u00d7 5 pixels each followed by a fully connected layer with 128 neurons. We also show the number of surrogate classes used for training each network. ",
        "Architecture": "",
        "Details of computing the measure of invariance": "We now explain in detail and motivate computation of the normalized Euclidean distance used as a measure of invariance in the paper.First we compute feature vectors of all image patches and their transformed versions. We next normalize each feature vector to unit Euclidean norm and compute Euclidean distances between each original patch and all of its transformed versions. For each transformation and magnitude we average these distances over all patches. Finally, we divide the resulting curves by their maximal values (typically it is the value for the maximum magnitude of the transformation).The normalizations are performed to compensate for possibly different scales of different features.Normalizing feature vectors to unit length ensures that the values are in the same range for different features. The final normalization of the curves by the maximal value allows to compensate for different variation of different features: as an extreme, a constant feature would be considered perfectly invariant without this normalization, which is certainly not desirable.The resulting curves show how quickly the feature representation changes when an image is transformed more and more. A representation for which the curve steeply goes up and then remains constant cannot be considered invariant to the transformation: the feature vector of the transformed patch becomes completely uncorrelated with the original feature vector even for small magnitudes of the transformation. On the other hand, if the curve grows gradually, this indicates that the feature representation changes slowly when the transformation is applied, meaning invariance or, rather, covariance of the representation. "
    },
    {
        "1": "Such cases could be covered either by careful selection of applied transformations or by combining features from multiple networks trained with different sets of transformations and letting the final classifier choose which features to use.",
        "2": "There are two ways to compute the test accuracy on Caltech-101: average accuracy over all samples (average overall accuracy) or calculate the accuracy for each class separately and then average these values (average per-class accuracy). These differ, as some classes contain fewer than 50 test samples. We found that most researchers in machine learning use average overall accuracy, hence this is what we report in the tables."
    },
    {
        "b0": [
            "Imagenet classification with deep convolutional neural networks",
            "",
            "",
            "",
            "Krizhevsky",
            "Sutskever",
            "Hinton"
        ],
        "b1": [
            "",
            "",
            "Visualizing and understanding convolutional networks",
            ""
        ],
        "b2": [
            "Backpropagation applied to handwritten zip code recognition",
            "",
            "",
            "",
            "Lecun",
            "Boser",
            "Denker",
            "Henderson",
            "Howard",
            "Hubbard",
            "Jackel"
        ],
        "b3": [
            "",
            "",
            "Decaf: A deep convolutional activation feature for generic visual recognition",
            ""
        ],
        "b4": [
            "",
            "",
            "Rich feature hierarchies for accurate object detection and semantic segmentation",
            ""
        ],
        "b5": [
            "Simple sparsification improves sparse denoising autoencoders in denoising highly corrupted images",
            "",
            "",
            "",
            "Cho"
        ],
        "b6": [
            "",
            "",
            "Descriptor matching with convolutional neural networks: a comparison to SIFT",
            ""
        ],
        "b7": [
            "Learning convolutional feature hierachies for visual recognition",
            "",
            "",
            "",
            "Kavukcuoglu",
            "Sermanet",
            "Boureau",
            "Gregor",
            "Mathieu",
            "Lecun"
        ],
        "b8": [
            "Extracting and composing robust features with denoising autoencoders",
            "",
            "",
            "",
            "Vincent",
            "Larochelle",
            "Bengio",
            "Manzagol"
        ],
        "b9": [
            "A generative process for contractive auto-encoders",
            "",
            "",
            "",
            "Rifai",
            "Dauphin",
            "Vincent",
            "Bengio"
        ],
        "b10": [
            "Deep learning of invariant features via simulated fixations in video",
            "",
            "",
            "",
            "Zou",
            "Ng",
            "Zhu",
            "Yu"
        ],
        "b11": [
            "Learning invariant representations with local transformations",
            "",
            "",
            "",
            "Sohn",
            "Lee"
        ],
        "b12": [
            "Direct modeling of complex invariances for visual object features",
            "",
            "",
            "",
            "Hui"
        ],
        "b13": [
            "Tangent prop -a formalism for specifying selected invariances in an adaptive network",
            "",
            "",
            "",
            "Simard",
            "Victorri",
            "Lecun",
            "Denker"
        ],
        "b14": [
            "Improving generalization performance using double backpropagation",
            "",
            "",
            "",
            "Drucker",
            "Lecun"
        ],
        "b15": [
            "Semi supervised logistic regression",
            "",
            "",
            "",
            "Amini",
            "Gallinari"
        ],
        "b16": [
            "Entropy regularization",
            "",
            "",
            "",
            "Grandvalet",
            "Bengio"
        ],
        "b17": [
            "Training hierarchical feed-forward visual recognition models using transfer learning from pseudo-tasks",
            "",
            "",
            "",
            "Ahmed",
            "Yu",
            "Xu",
            "Gong",
            "Xing"
        ],
        "b18": [
            "Natural language processing (almost) from scratch",
            "",
            "",
            "",
            "Collobert",
            "Weston",
            "Bottou",
            "Karlen",
            "Kavukcuoglu",
            "Kuksa"
        ],
        "b19": [
            "Dropout training as adaptive regularization",
            "",
            "",
            "",
            "Wager",
            "Wang",
            "Liang"
        ],
        "b20": [
            "The manifold tangent classifier",
            "",
            "",
            "",
            "Rifai",
            "Dauphin",
            "Vincent",
            "Bengio",
            "Muller"
        ],
        "b21": [
            "An analysis of single-layer networks in unsupervised feature learning",
            "",
            "",
            "",
            "Coates",
            "Lee",
            "Ng"
        ],
        "b22": [
            "",
            "",
            "Learning multiple layers of features from tiny images. Master's thesis",
            ""
        ],
        "b23": [
            "Learning Generative Visual Models from Few Training Examples: An Incremental Bayesian Approach Tested on 101 Object Categories",
            "",
            "",
            "",
            "Fei-Fei",
            "Fergus",
            "Perona"
        ],
        "b24": [
            "",
            "",
            "Improving neural networks by preventing co-adaptation of feature detectors",
            ""
        ],
        "b25": [
            "",
            "",
            "Caffe: An open source convolutional architecture for fast feature embedding",
            "http://caffe.berkeleyvision.org/"
        ],
        "b26": [
            "Selecting receptive fields in deep networks",
            "",
            "",
            "",
            "Coates",
            "Ng"
        ],
        "b27": [
            "Unsupervised Feature Learning for RGB-D Based Object Recognition",
            "",
            "",
            "",
            "Bo",
            "Ren",
            "Fox"
        ],
        "b28": [
            "Ask the locals: multi-way local pooling for image recognition",
            "",
            "",
            "",
            "Boureau",
            "Le Roux",
            "Bach",
            "Ponce",
            "Lecun"
        ],
        "b29": [
            "Multipath sparse coding using hierarchical matching pursuit",
            "",
            "",
            "",
            "Bo",
            "Ren",
            "Fox"
        ]
    },
    {
        "tab_0": "Table 1 :1Classification accuracies on several datasets (in percent). \u2020 Average per-class accuracy 2 78.0% \u00b1 0.4%. \u2021 Average per-class accuracy 84.4% \u00b1 0.6%.AlgorithmSTL-10 CIFAR-10(400) CIFAR-10 Caltech-101 #featuresConvolutional K-means Network [27]60.1 \u00b1 170.7 \u00b1 0.782.0-8000Multi-way local pooling [29]---77.3 \u00b1 0.6 1024 \u00d7 64Slowness on videos [11]61.0--74.6556Hierarchical Matching Pursuit (HMP) [28] 64.5 \u00b1 1---1000Multipath HMP [30]---82.5 \u00b1 0.55000View-Invariant K-means [13]63.772.6 \u00b1 0.781.9-6400Small net (64c5-64c5-128f)67.1 \u00b1 0.369.7 \u00b1 0.375.779.8 \u00b1 0.5 \u2020256Large net (64c5-128c5-256c5-512f)72.8 \u00b1 0.4 75.3 \u00b1 0.282.085.5 \u00b1 0.4 \u2021960",
        "tab_1": "Table 3 :3Dependence of classification performance (in %) on the training and testing datasets. Each column corresponds to different test data, each row to different training data (i.e. source of seed patches). We used the \"small\" network (64c5-64c5-128f) for this experiment.#classes STL-10 CIFAR-10(400) CIFAR-10 Caltech-10132c5-32c5-64f8000 63.8 \u00b1 0.466.1 \u00b1 0.471.378.2 \u00b1 0.664c5-64c5-128f8000 67.1 \u00b1 0.369.7 \u00b1 0.375.779.8 \u00b1 0.564c7-64c5-128f8000 66.3 \u00b1 0.469.5 \u00b1 0.375.079.4 \u00b1 0.764c5-64c5-64c5-128f8000 68.5 \u00b1 0.370.9 \u00b1 0.377.082.2 \u00b1 0.764c5-64c5-64c5-64c5-128f 8000 64.7 \u00b1 0.567.5 \u00b1 0.375.275.7 \u00b1 0.4128c5-64c5-128f8000 67.2 \u00b1 0.469.9 \u00b1 0.276.180.1 \u00b1 0.564c5-256c5-128f8000 69.2 \u00b1 0.371.7 \u00b1 0.377.981.6 \u00b1 0.564c5-64c5-512f8000 69.0 \u00b1 0.471.7 \u00b1 0.279.382.9 \u00b1 0.4128c5-256c5-512f8000 71.2 \u00b1 0.373.9 \u00b1 0.381.584.3 \u00b1 0.6128c5-256c5-512f16000 71.9 \u00b1 0.374.3 \u00b1 0.381.484.6 \u00b1 0.664c5-128c5-256c5-512f16000 72.8 \u00b1 0.475.3 \u00b1 0.382.085.5 \u00b1 0.4TESTINGTRAININGSTL-10CIFAR-10(400) CALTECH-101STL-1067.5 \u00b1 0.469.5 \u00b1 0.376.8 \u00b1 0.4CIFAR-1064.0 \u00b1 0.570.2 \u00b1 0.277.9 \u00b1 0.7CALTECH-101 64.0 \u00b1 0.368.4 \u00b1 0.379.2 \u00b1 0.6"
    }
]