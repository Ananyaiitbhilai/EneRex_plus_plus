[
    {
        "basename": "0dc9eb7d17f2def56ad930945f2521653f04c3fa.grobid",
        "fulltext": 18,
        "footnote_size": 5,
        "footnote_max": 5,
        "reference": 15,
        "authors": [
            "Shazeer"
        ]
    },
    {
        "title": "Skip-gram Language Modeling Using Sparse Non-negative Matrix Probability Estimation",
        "abstract": "We present a novel family of language model (LM) estimation techniques named Sparse Non-negative Matrix (SNM) estimation. A first set of experiments empirically evaluating it on the One Billion Word Benchmark [Chelba et al., 2013] shows that SNM n-gram LMs perform almost as well as the well-established Kneser-Ney (KN) models. When using skip-gram features the models are able to match the state-of-the-art recurrent neural network (RNN) LMs; combining the two modeling techniques yields the best known result on the benchmark. The computational advantages of SNM over both maximum entropy and RNN LM estimation are probably its main strength, promising an approach that has the same flexibility in combining arbitrary features effectively and yet should scale to very large amounts of data as gracefully as n-gram LMs do.",
        "Introduction": "A statistical language model estimates the prior probability values P (W ) for strings of words W in a vocabulary V whose size is in the tens, hundreds of thousands and sometimes even millions. Typically the string W is broken into sentences, or other segments such as utterances in automatic speech recognition, which are assumed to be conditionally independent; we will assume that W is such a segment, or sentence.Estimating full sentence language models is computationally hard if one seeks a properly normalized probability model 1 over strings of words of finite length in V * . A simple and sufficient way to ensure proper normalization of the model is to decompose the sentence probability according to the chain rule and make sure that the end-of-sentence symbol </s> is predicted with non-zero probability in any context. With W = w 1 , w 2 , . . . , w n we get:P (W ) = n i=1 P (w i |w 1 , w 2 , . . . , w i-1 )(1)Since the parameter space of P (w k |w 1 , w 2 , . . . , w k-1 ) is too large, the language model is forced to put the context W k-1 = w 1 , w 2 , . . . , w k-1 into an equivalence class determined by a function \u03a6(W k-1 ). As a result,P (W ) \u223c = n k=1 P (w k |\u03a6(W k-1 ))(2)The word strings encountered in a practical application are of finite length. The probability distribution P (W ) should assign probability 0.0 to strings of words of infinite length, and thus sum up to 1.0 over the set of strings of finite lengththe support of P (W ). From a modeling point of view in a practical situation, the text gets broken into sentences, and the language model needs to predict the distinguished end-of-sentence symbol </s>. It can be easily shown that if the language model is smooth, i.e. P (w k |\u03a6(W k-1 )) > \u01eb > 0, \u2200w k , W k-1 , then we also have P (</s>|\u03a6(W k-1 )) > \u01eb > 0, \u2200W k-1 which in turn ensures that the model assigns probability 1.0 to the set strings of words of finite length.Research in language modeling consists of finding appropriate equivalence classifiers \u03a6 and methods to estimate P (w k |\u03a6(W k-1 )). The most successful paradigm in language modeling uses the (n -1)-gram equivalence classification, that is, defines\u03a6(W k-1 ) . = w k-n+1 , w k-n+2 , . . . , w k-1Once the form \u03a6(W k-1 ) is specified, only the problem of estimating P (w k |\u03a6(W k-1 )) from training data remains.",
        "Perplexity as a Measure of Language Model Quality": "A statistical language model can be evaluated by how well it predicts a string of symbols W t -commonly referred to as test data-generated by the source to be modeled.model is side-stepped at a gain in modeling power and simplicity.A commonly used quality measure for a given model M is related to the entropy of the underlying source and was introduced under the name of perplexity (PPL)  #b13 :P P L(M ) = exp(- 1 N N k=1 ln [P M (w k |W k-1 )])(3)To give intuitive meaning to perplexity, it represents the number of guesses the model needs to make in order to ascertain the identity of the next word, when running over the test word string from left to right. It can be easily shown that the perplexity of a language model that uses the uniform probability distribution over words in the vocabulary V equals the size of the vocabulary; a good language model should of course have lower perplexity, and thus the vocabulary size is an upper bound on the perplexity of any sensible language model. Very likely, not all words in the test string W t are part of the language model vocabulary. It is common practice to map all words that are out-of-vocabulary to a distinguished unknown word symbol, and report the out-of-vocabulary (OOV) rate on test data-the rate at which one encounters OOV words in the test string W tas yet another language model performance metric besides perplexity. Usually the unknown word is assumed to be part of the language model vocabulary-open vocabulary language models-and its occurrences are counted in the language model perplexity calculation, Eq. (3). A situation less common in practice is that of closed vocabulary language models where all words in the test data will always be part of the vocabulary V.",
        "Skip-gram Language Modeling": "Recently, neural network (NN) smoothing  #b0 ,  #b2 , [Schwenk, 2007], and in particular recurrent neural networks  #b7  (RNN) have shown excellent performance in language modeling  #b11 . Their excellent performance is attributed to a combination of leveraging long-distance context, and training a vector representation for words.Another simple way of leveraging long distance context is to use skip-grams. In our approach, a skip-gram feature extracted from the context W k-1 is characterized by the tuple (r, s, a) where:\u2022 r denotes number of remote context words \u2022 s denotes the number of skipped words\u2022 a denotes the number of adjacent context words relative to the target word w k being predicted. For example, in the sentence, <S> The quick brown fox jumps over the lazy dog </S> a (1, 2, 3) skip-gram feature for the target word dog is: [brown skip-2 over the lazy]For performance reasons, it is recommended to limit s and to limit either (r+a) or limit both r and s; not setting any limits will result in events containing a set of skip-gram features whose total representation size is quintic in the length of the sentence.We configure the skip-gram feature extractor to produce all features f , defined by the equivalence class \u03a6(W k-1 ), that meet constraints on the minimum and maximum values for:\u2022 the number of context words used r + a;\u2022 the number of remote words r;\u2022 the number of adjacent words a;\u2022 the skip length s.We also allow the option of not including the exact value of s in the feature representation; this may help with smoothing by sharing counts for various skip features. Tied skip-gram features will look like: [curiousity skip-* the cat]In order to build a good probability estimate for the target word w k in a context W k-1 we need a way of combining an arbitrary number of skip-gram features f k-1 , which do not fall into a simple hierarchy like regular n-gram features. The following section describes a simple, yet novel approach for combining such predictors in a way that is computationally easy, scales up gracefully to large amounts of data and as it turns out is also very effective from a modeling point of view.",
        "Sparse Non-negative Matrix Modeling": "",
        "Model definition": "In the Sparse Non-negative Matrix (SNM) paradigm, we represent the training data as a sequence of events E = e 1 , e 2 , ... where each event e \u2208 E consists of a sparse non-negative feature vector f and a sparse non-negative target word vector t. A language model is represented by a non-negative matrix M that, when applied to a given feature vector f , produces a dense prediction vector y:y = Mf \u2248 t (4)Upon evaluation, we normalize y such that we end up with a conditional probability distribution P M (t|f ) for a model M. For each word w \u2208 V that corresponds to index j in t, and its feature vector f that is defined by the equivalence class \u03a6 applied to the history h(w) of that word in a text, the conditional probability P M (w|\u03a6(h(w))) then becomes:P M (w|\u03a6(h(w))) = P M (t j |f ) = y j |V| u=1 y u = i\u2208P os(f ) M ij i\u2208P os(f ) |V| u=1 M iu(5)For convenience, we will write P (t j |f ) instead of P M (t j |f ) in the rest of the paper.As required by the denominator in Eq. ( 5), this computation involves summing over all of the present features for the entire vocabulary. However, if we precompute the row sums |V| u=1 M iu and store them together with the model, the evaluation can be done very efficiently in only |P os(f )| time. Moreover, only the positive entries in M i need to be considered, making the range of the sum sparse.",
        "Adjustment function and metafeatures": "We let the entries of M be a slightly modified version of the relative frequencies:M ij = e A(i,j) C ij C i * (6)where C is a feature-target count matrix, computed over the entire training corpus and A(i, j) is a real-valued function, dubbed adjustment function. For each featuretarget pair (f i , t j ), the adjustment function extracts k new features \u03b1 k , called metafeatures, which are hashed as keys to store corresponding weights \u03b8(hash(\u03b1 k )) in a huge hash table. To limit memory usage, we use a flat hash table and allow collisions, although this has the potentially undesirable effect of tying together the weights of different metafeatures. Computing the adjustment function for any (f i , t j ) then amounts to summing the weights that correspond to its metafeatures:A(i, j) = k \u03b8(hash[\u03b1 k (i, j)])(7)From the given input features, such as regular n-grams and skip n-grams, we construct our metafeatures as conjunctions of any or all of the following elementary metafeatures:\u2022 feature identity, e.g. [brown skip-2 over the lazy]\u2022 feature type, e.g. (1, 2, 3) skip-grams\u2022 feature count C i *\u2022 target identity, e.g. dog\u2022 feature-target count C ij where we reused the example from Section 2. Note that the seemingly absent feature-target identity is represented by the conjunction of the feature identity and the target identity. Since the metafeatures may involve the feature count and feature-target count, in the rest of the paper we will write \u03b1 k (i, j, C i * , C ij ). This will become important later when we discuss leave-one-out training. Each elementary metafeature is joined with the others to form more complex metafeatures which in turn are joined with all the other elementary and complex metafeatures, ultimately ending up with all 2 5 -1 possible combinations of metafeatures.Before they are joined, count metafeatures are bucketed together according to their (floored) log 2 value. As this effectively puts the lowest count values, of which there are many, into a different bucket, we optionally introduce a second (ceiled) bucket to assure smoother transitions. Both buckets are then weighted according to the log 2 fraction lost by the corresponding rounding operation. Note that if we apply double bucketing to both the feature and feature-target count, the amount of metafeatures per input feature becomes 2 7 -1.We will come back to these metafeatures in Section 4.4 where we examine their individual effect on the model.",
        "Loss function": "Estimating a model M corresponds to finding optimal weights \u03b8 k for all the metafeatures for all events in such a way that the average loss over all events between the target vector t and the prediction vector y is minimized, according to some loss function L. The most natural choice of loss function is one that is based on the multinomial distribution. That is, we consider t to be multinomially distributed with |V| possible outcomes. The loss function L multi then is:L multi (y, t) = -log(P multi (t|f )) = -log( y j |V| u=1 y u ) = log( |V| u=1 y u ) -log(y j )(8)Another possibility is the loss function based on the Poisson distribution2 : we consider each t j in t to be Poisson distributed with parameter y j . The conditional probability of P P oisson (t|f ) then is:P P oisson (t|f ) = j\u2208t y t j j e -y j t j !(9)and the corresponding Poisson loss function is:L P oisson (y, t) = -log(P P oisson (t|f )) = - j\u2208t [t j log(y j ) -y j -log(t j !)] = j\u2208t y j - j\u2208t t j log(y j )(10)where we dropped the last term, since t j is binary-valued3 . Although this choice is not obvious in the context of language modeling, it is well suited to gradient-based optimization and, as we will see, the experimental results are in fact excellent.",
        "Model Estimation": "The adjustment function is learned by applying stochastic gradient descent on the loss function. That is, for each feature-target pair (f i , t j ) in each event we need to update the parameters of the metafeatures by calculating the gradient with respect to the adjustment function.For the multinomial loss, this gradient is:\u2202(L multi (Mf , t)) \u2202(A(i, j)) = \u2202(log( |V| u=1 (Mf ) u ) -log(Mf ) j ) \u2202(M ij ) \u2202(M ij ) \u2202(A ij ) = [ \u2202(log( |V| u=1 (Mf ) u )) \u2202(M ij ) - \u2202(log(Mf ) j ) \u2202(M ij ) ]M ij = [ \u2202( |V| u=1 (Mf ) u ) |V| u=1 (Mf ) u \u2202(M ij ) - \u2202(Mf ) j (Mf ) j \u2202(M ij ) ]M ij = ( f i |V| u=1 (Mf ) u - f i y j )M ij = f i M ij ( 1 |V| u=1 y u - 1 y j )(11)The problem with this update rule is that we need to sum over the entire vocabulary V in the denominator. For most features f i , this is not a big deal as C iu = 0, but some features occur with many if not all targets e.g. the empty feature for unigrams. Although we might be able to get away with this by re-using these sums and applying them to many/all events in a mini batch, we chose to work with the Poisson loss in our first implementation.If we calculate the gradient of the Poisson loss, we get the following:\u2202(L P oisson (Mf , t)) \u2202(A(i, j)) = \u2202( |V| u=1 (Mf ) u - |V| u=1 t u log(Mf ) u ) \u2202(M ij ) \u2202(M ij ) \u2202(A(i, j)) = [ \u2202( |V| u=1 (Mf ) u ) \u2202(M ij ) - \u2202( |V| u=1 t u log(Mf ) u ) \u2202(M ij ) ]M ij = [f i - t j (Mf ) j \u2202(Mf ) j \u2202(M ij ) ]M ij = [f i - t j f i (Mf ) j ]M ij = f i M ij (1 - t j y j )(12)If we were to apply this gradient to each (positive and negative) training example, it would be computationally too expensive, because even though the second term is zero for all the negative training examples, the first term needs to be computed for all |E||P os(f )||V| training examples.However, since the first term does not depend on y j , we are able to distribute the updates for the negative examples over the positive ones by adding in gradients for a fraction of the events where f i = 1, but t j = 0. In particular, instead of adding the term f i M ij , we addf i t j C i * C ij M ij : C i * C ij M ij e=(f i ,t j )\u2208E f i t j = C i * C ij M ij C ij = M ij e=(f i ,t j )\u2208E f i (13)which lets us update the gradient only on positive examples. We note that this update is only strictly correct for batch training, and not for online training since M ij changes after each update. Nonetheless, we found this to yield good results as well as seriously reducing the computational cost. The online gradient applied to each training example then becomes:\u2202(L P oisson (Mf , t)) \u2202(A(i, j)) = f i t j M ij ( C i * C ij - 1 y j ) (14)which is non-zero only for positive training examples, hence speeding up computation by a factor of |V|. These aggregated gradients however do not allow us to use additional data to train the adjustment function, since they tie the update computation to the relative frequencies C i * C ij . Instead, we have to resort to leave-one-out training to prevent the model from overfitting the training data. We do this by excluding the event, generating the gradients, from the counts used to compute those gradients. So, for each positive example (f i , t j ) of each event e = (f , t), we compute the gradient, excluding f i from C i * and f i t j from C ij . For the gradients of the negative examples on the other hand we only exclude f i from C i * and we leave C ij untouched, since here we did not observe t j . In order to keep the aggregate computation of the gradients for the negative examples, we distribute them uniformly over all the positive examples with the same feature; each of the C ij positive examples will then compute the gradient ofC i * -C ij C ijnegative examples. To summarize, when we do leave-one-out training we apply the following gradient update rule on all positive training examples:\u2202(L P oisson (Mf , t)) \u2202(A(i, j)) = f i t j C i * -C ij C ij C ij C i * -1 e k \u03b8(hash[\u03b1 k (i,j,C i * -1,C ij )]) + f i t j C ij -1 C i * -1 y \u2032 j -1 y \u2032 j e k \u03b8(hash[\u03b1 k (i,j,C i * -1,C ij -1)]) (15)where y \u2032 j is the product of leaving one out for all the relevant features i.e.y \u2032 j = (M \u2032 f ) j and M \u2032 ij = e k \u03b8(hash[\u03b1 k (i,j,C i * -1,C ij -1)]) C ij -1 C i * -1 .",
        "Experiments": "",
        "Corpus: One Billion Benchmark": "Our experimental setup used the One Billion Word Benchmark corpus4 made available by  #b11 .For completeness, here is a short description of the corpus, containing only monolingual English data:\u2022 Total number of training tokens is about 0.8 billion  1: Perplexity results for Kneser-Ney, Katz and SNM, as well as for the linear interpolation of Kneser-Ney and SNM. Optimal interpolation weights are always around 0.6 -0.7 (KN) and 0.3 -0.4 (SNM).\u2022 Words outside of the vocabulary were mapped to <UNK> token, also part of the vocabulary\u2022 Sentence order was randomized\u2022 The test data consisted of 159658 words (without counting the sentence beginning marker <S> which is never predicted by the language model)\u2022 The out-of-vocabulary (OoV) rate on the test set was 0.28%.",
        "SNM for n-gram LMs": "When trained using solely n-gram features, SNM comes very close to the stateof-the-art Kneser-Ney  #b6  (KN) models. Table 1 shows that Katz  #b5  performs considerably worse than both SNM and KN which only differ by about 5%. When we interpolate these two models linearly, the added gain is only about 1%, suggesting that they are approximately modeling the same things. The difference between KN and SNM becomes smaller when we increase the size of the context, going from 5% for 5-grams to 3% for 8-grams, which indicates that SNM is better suited to a large number of features.",
        "Sparse Non-negative Modeling for Skip n-grams": "When we incorporate skip-gram features, we can either build a 'pure' skip-gram SNM that contains no regular n-gram features, except for unigrams, and interpolate this model with KN, or we can build a single SNM that has both the regular ngram features and the skip-gram features. We compared the two approaches by choosing skip-gram features that can be considered the skip-equivalent of 5-grams i.e. they contain at most 4 words. In particular, we used skip-gram features where the remote span is limited to at most 3 words for skips of length between 1 and 3 We then built a model that uses both these features and regular 5-grams (SNM5-skip), as well as one that only uses the skip-gram features (SNM5skip (no n-grams)).(r = [1..3], s = [1..3], r + a = [1..4])As it turns out and as can be seen from Table 2, it is better to incorporate all the features into one single SNM model than to interpolate with a KN 5-gram model (KN5). Interpolating the all-in-one SNM5-skip with KN5 yields almost no additional gain.The best SNM results so far (SNM10-skip) were achieved using 10-grams, together with untied skip features of at most 5 words with a skip of exactly 1 word (s = 1, r + a = [1..5]) as well as tied skip features of at most 4 words where only 1 word is remote, but up to 10 words can be skipped (r = 1, s = [1..10], r + a = [1..4]).This mixture of rich short-distance and shallow long-distance features enables the model to achieve state-of-the-art results, as can be seen in Table 3. When we compare the perplexity of this model with the state-of-the art RNN results in  #b11 , the difference is only 3%. Moreover, although our model has more parameters than the RNN (33 vs 20 billion), training takes about a tenth of the time (24 hours vs 240 hours). Interestingly, when we interpolate the two models, we have an additional gain of 20%, and as far as we know, the perplexity of 41.3 is already the best ever reported on this database, beating the previous best by 6%  #b11 .Finally, when we optimize interpolation weights over all models in  #b11 , including SNM5-skip and SNM10-skip, the contribution of the other models as well as the perplexity reduction is negligible, as can be seen in Table 3, which also summarizes the perplexity results for each of the individual models.   #b11 , and SNM5-skip and SNM10-skip, as well as interpolation results and weights.",
        "Model": "",
        "Ablation Experiments": "To find out how much, if anything at all, each metafeature contributes to the adjustment function, we ran a series of ablation experiments in which we ablated one metafeature at a time. When we experimented on SNM5, we found, unsurprisingly, that the most important metafeature is the feature-target count. At first glance, it does not seem to matter much whether the counts are stored in 1 or 2 buckets, but the second bucket really starts to pay off for models with a large number of singleton features e.g. SNM10-skip5 . This is not the case for the feature counts, where having a single bucket is always better, although in general the feature counts do not contribute much. In any case, feature counts are definitely the least important for the model. The remaining metafeatures all contribute more or less equally, all of which can be seen in Table 4.",
        "Related Work": "SNM estimation is closely related to all n-gram LM smoothing techniques that rely on mixing relative frequencies at various orders. Unlike most of those, it combines the predictors at various orders without relying on a hierarchical nesting of the contexts, setting it closer to the family of maximum entropy (ME)  #b8  We are not the first ones to highlight the effectiveness of skip n-grams at capturing dependencies across longer contexts, similar to RNN LMs; previous such results were reported in  #b14 .The speed-ups to ME, and RNN LM training provided by hierarchically predicting words at the output layer [Goodman, 2001b], and subsampling  #b14  still require updates that are linear in the vocabulary size times the number of words in the training data, whereas the SNM updates in Eq. ( 15) for the much smaller adjustment function eliminate the dependency on the vocabulary size.The computational advantages of SNM over both Maximum Entropy and RNN LM estimation are probably its main strength, promising an approach that has the same flexibility in combining arbitrary features effectively and yet should scale to very large amounts of data as gracefully as n-gram LMs do.",
        "Conclusions and Future Work": "We have presented SNM, a new family of LM estimation techniques. A first empirical evaluation on the One Billion Word Benchmark  #b11  shows that SNM n-gram LMs perform almost as well as the well-established KN models.When using skip-gram features the models are able to match the stat-of-the-art RNN LMs; combining the two modeling techniques yields the best known result on the benchmark.Future work items include model pruning, exploring richer features similar to [Goodman, 2001a], as well as richer metafeatures in the adjustment model, mixing SNM models trained on various data sources such that they perform best on a given development set, and estimation techniques that are more flexible in this respect."
    },
    {
        "1": "We note that in some practical systems the constraint on using a properly normalized language",
        "2": "Although we do not use it at this point, the Poisson loss also lends itself nicely for multiple target prediction which might be useful in e.g. subword modeling.",
        "3": "In fact, even in the general case where t k can take any non-negative value, this term will disappear in the gradient, as it is independent of M.",
        "4": "http://www.statmt.org/lm-benchmark",
        "5": "Ideally we want to have the SNM10-skip ablation results as well, but this takes up a lot of time, during which other development is hindered."
    },
    {
        "b0": [
            "A neural probabilistic language model",
            "",
            "",
            "",
            "Bengio"
        ],
        "b1": [
            "",
            "",
            "",
            "",
            "Brown"
        ],
        "b2": [
            "",
            "",
            "A Neural Syntactic Language Model",
            ""
        ],
        "b3": [
            "",
            "",
            "A bit of progress in language modeling, extended version",
            ""
        ],
        "b4": [
            "Classes for fast maximum entropy training",
            "",
            "",
            "",
            "Goodman ; B]",
            "Goodman"
        ],
        "b5": [
            "Estimation of probabilities from sparse data for the language model component of a speech recognizer",
            "",
            "",
            "",
            "Katz",
            "Katz"
        ],
        "b6": [
            "Improved Backing-Off For M-Gram Language Modeling",
            "",
            "",
            "",
            "Kneser",
            "Kneser",
            "Ney"
        ],
        "b7": [
            "Hierarchical Probabilistic Neural Network Language Model",
            "",
            "",
            "",
            "Mikolov",
            "Mikolov",
            "Morin",
            "Bengio"
        ],
        "b8": [
            "Adaptive Statistical Language Modeling: A Maximum Entropy Approach",
            "",
            "",
            "",
            "Rosenfeld",
            "Rosenfeld"
        ],
        "b9": [
            "LSTM Neural Networks for Language Modeling",
            "",
            "",
            "",
            "Sundermeyer"
        ],
        "b10": [
            "A hierarchical Bayesian language model based on PitmanYor processes",
            "",
            "",
            "",
            "Teh",
            "Teh"
        ],
        "b11": [
            "",
            "",
            "One Billion Word Benchmark for Measuring Progress in Statistical Language Modeling",
            ""
        ],
        "b12": [
            "Interpolated estimation of Markov source parameters from sparse data",
            "",
            "",
            "",
            "Jelinek",
            "Jelinek",
            "Mercer"
        ],
        "b13": [
            "",
            "",
            "Frederick Jelinek 1997. Information Extraction From Speech And Text",
            ""
        ],
        "b14": [
            "Comparing RNNs and log-linear interpolation of improved skip-model on four Babel languages: Cantonese, Pashto, Tagalog, Turkish",
            "",
            "",
            "",
            "Singh",
            "Singh",
            "Klakow",
            "Xu"
        ]
    },
    {
        "tab_2": "Table 3 :3Number of parameters (in billions) and perplexity results for each of the models inNum. Params PPL interpolation weightsKN51.76 B67.60.060.00HSME6 B101.30.000.00SBO1.13 B87.90.200.04SNM5-skip62 B54.20.10SNM10-skip33 B52.90.40.27RNN25620 B58.20.000.00RNN51220 B54.60.130.07RNN102420 B51.30.6 0.610.53SNM10-skip+RNN102441.3Previous best43.8ALL41.0",
        "tab_3": "Table 4 :4, Metafeature ablation experiments on SNM5 or exponential models.Ablated featurePPLNo ablation70.8Feature71.9Feature type71.4Feature count70.6Feature count: second bucket 70.3Link count73.2Link count: second bucket70.6"
    }
]