[
    {
        "basename": "3cf31ecb2724b5088783d7c96a5fc0d5604cbf41.grobid",
        "fulltext": 19,
        "footnote_size": 10,
        "footnote_max": 316,
        "reference": 46,
        "authors": [
            "Kiperwasser",
            "Goldberg"
        ]
    },
    {
        "title": "Simple and Accurate Dependency Parsing Using Bidirectional LSTM Feature Representations",
        "abstract": "We present a simple and effective scheme for dependency parsing which is based on bidirectional-LSTMs (BiLSTMs). Each sentence token is associated with a BiLSTM vector representing the token in its sentential context, and feature vectors are constructed by concatenating a few BiLSTM vectors. The BiLSTM is trained jointly with the parser objective, resulting in very effective feature extractors for parsing. We demonstrate the effectiveness of the approach by applying it to a greedy transition-based parser as well as to a globally optimized graph-based parser. The resulting parsers have very simple architectures, and match or surpass the state-of-the-art accuracies on English and Chinese.",
        "Introduction": "The focus of this paper is on feature representation for dependency parsing, using recent techniques from the neural-networks (\"deep learning\") literature. Modern approaches to dependency parsing can be broadly categorized into graph-based and transition-based parsers  #b21 . Graph-based parsers (McDonald, 2006) treat parsing as a search-based structured prediction problem in which the goal is learning a scoring function over dependency trees such that the correct tree is scored above all other trees. Transition-based parsers  #b33  #b34  treat parsing as a sequence of actions that produce a parse tree, and a classifier is trained to score the possible actions at each stage of the process and guide the parsing process. Perhaps the simplest graph-based parsers are arc-factored (first order) models  #b32 , in which the scoring function for a tree decomposes over the individual arcs of the tree. More elaborate models look at larger (overlapping) parts, requiring more sophisticated inference and training algorithms  #b29 Koo and Collins, 2010). The basic transition-based parsers work in a greedy manner, performing a series of locally-optimal decisions, and boast very fast parsing speeds. More advanced transition-based parsers introduce some search into the process using a beam  #b43  or dynamic programming  #b13 .Regardless of the details of the parsing framework being used, a crucial step in parser design is choosing the right feature function for the underlying statistical model. Recent work (see Section 2.2 for an overview) attempt to alleviate parts of the feature function design problem by moving from linear to non-linear models, enabling the modeler to focus on a small set of \"core\" features and leaving it up to the machine-learning machinery to come up with good feature combinations  #b1  #b35  #b26  #b38 . However, the need to carefully define a set of core features remains. For example, the work of  #b1  uses 18 different elements in its feature function, while the work of  #b35  uses 21 different elements. Other works, notably  #b5  and  #b24 , propose more sophisticated feature representations, in which the feature engineering is replaced with architecture engineering.In this work, we suggest an approach which is much simpler in terms of both feature engineering 313 Transactions of the Association for Computational Linguistics, vol. 4, pp. 313-327, 2016. Action Editor: Marco Kuhlmann.Submission batch: 2/2016; Published 7/2016. c 2016 Association for Computational Linguistics. Distributed under a CC-BY 4.0 license. and architecture engineering. Our proposal (Section 3) is centered around BiRNNs  #b14  #b36 , and more specifically BiLSTMs  #b11 , which are strong and trainable sequence models (see Section 2.3). The BiLSTM excels at representing elements in a sequence (i.e., words) together with their contexts, capturing the element and an \"infinite\" window around it. We represent each word by its BiLSTM encoding, and use a concatenation of a minimal set of such BiLSTM encodings as our feature function, which is then passed to a non-linear scoring function (multi-layer perceptron). Crucially, the BiLSTM is trained with the rest of the parser in order to learn a good feature representation for the parsing problem. If we set aside the inherent complexity of the BiLSTM itself and treat it as a black box, our proposal results in a pleasingly simple feature extractor.We demonstrate the effectiveness of the approach by using the BiLSTM feature extractor in two parsing architectures, transition-based (Section 4) as well as a graph-based (Section 5). In the graphbased parser, we jointly train a structured-prediction model on top of a BiLSTM, propagating errors from the structured objective all the way back to the BiLSTM feature-encoder. To the best of our knowledge, we are the first to perform such end-to-end training of a structured prediction model and a recurrent feature extractor for non-sequential outputs. 1Aside from the novelty of the BiLSTM feature extractor and the end-to-end structured training, we rely on existing models and techniques from the parsing and structured prediction literature. We stick to the simplest parsers in each categorygreedy inference for the transition-based architecture, and a first-order, arc-factored model for the graph-based architecture. Despite the simplicity of the parsing architectures and the feature functions, we achieve near state-of-the-art parsing accuracies in both English (93.1 UAS) and Chinese (86.6 UAS), using a first-order parser with two features and while training solely on Treebank data, without relying on semi-supervised signals such as pre-trained word embeddings  #b1 , word-clusters  #b20 , or tech-niques such as tri-training  #b42 . When also including pre-trained word embeddings, we obtain further improvements, with accuracies of 93.9 UAS (English) and 87.6 UAS (Chinese) for a greedy transition-based parser with 11 features, and 93.6 UAS (En) / 87.4 (Ch) for a greedy transitionbased parser with 4 features.",
        "Background and Notation": "Notation We use x 1:n to denote a sequence of n vectors x 1 , \u2022 \u2022 \u2022 , x n . F \u03b8 (\u2022) is a function parameterized with parameters \u03b8. We write F L (\u2022) as shorthand for F \u03b8 L -an instantiation of F with a specific set of parameters \u03b8 L . We use \u2022 to denote a vector concatenation operation, and v[i] to denote an indexing operation taking the ith element of a vector v.",
        "Feature Functions in Dependency Parsing": "Traditionally, state-of-the-art parsers rely on linear models over hand-crafted feature functions. The feature functions look at core components (e.g. \"word on top of stack\", \"leftmost child of the second-totop word on the stack\", \"distance between the head and the modifier words\"), and are comprised of several templates, where each template instantiates a binary indicator function over a conjunction of core elements (resulting in features of the form \"word on top of stack is X and leftmost child is Y and . . . \"). The design of the feature function -which components to consider and which combinations of components to include -is a major challenge in parser design. Once a good feature function is proposed in a paper it is usually adopted in later works, and sometimes tweaked to improve performance. Examples of good feature functions are the feature-set proposed by  #b44  for transitionbased parsing (including roughly 20 core components and 72 feature templates), and the featureset proposed by  #b31  for graphbased parsing, with the paper listing 18 templates for a first-order parser, while the first order featureextractor in the actual implementation's code (MST-Parser2 ) includes roughly a hundred feature templates.The core features in a transition-based parser usually look at information such as the word-identity and part-of-speech (POS) tags of a fixed number of words on top of the stack, a fixed number of words on the top of the buffer, the modifiers (usually leftmost and right-most) of items on the stack and on the buffer, the number of modifiers of these elements, parents of words on the stack, and the length of the spans spanned by the words on the stack. The core features of a first-order graph-based parser usually take into account the word and POS of the head and modifier items, as well as POS-tags of the items around the head and modifier, POS tags of items between the head and modifier, and the distance and direction between the head and modifier.",
        "Related Research Efforts": "Coming up with a good feature-set for a parser is a hard and time consuming task, and many researchers attempt to reduce the required manual effort. The work of  #b26  suggests a low-rank tensor representation to automatically find good feature combinations.  #b38  suggest a kernel-based approach to implicitly consider all possible feature combinations over sets of core-features. The recent popularity of neural networks prompted a move from templates of sparse, binary indicator features to dense core feature encodings fed into non-linear classifiers.  #b1  encode each core feature of a greedy transition-based parser as a dense low-dimensional vector, and the vectors are then concatenated and fed into a nonlinear classifier (multi-layer perceptron) which can potentially capture arbitrary feature combinations.  #b42  showed further gains using the same approach coupled with a somewhat improved set of core features, a more involved network architecture with skip-layers, beam search-decoding, and careful hyper-parameter tuning.  #b35  apply a similar methodology to graph-based parsing. While the move to neural-network classifiers alleviates the need for hand-crafting featurecombinations, the need to carefully define a set of core features remain. For example, the feature representation in Chen and Manning (2014) is a concatenation of 18 word vectors, 18 POS vectors and 12 dependency-label vectors. 3The above works tackle the effort in hand-crafting effective feature combinations. A different line of work attacks the feature-engineering problem by suggesting novel neural-network architectures for encoding the parser state, including intermediatelybuilt subtrees, as vectors which are then fed to nonlinear classifiers. Titov and Henderson encode the parser state using incremental sigmoid-belief networks (2007). In the work of  #b5 , the entire stack and buffer of a transition-based parser are encoded as a stack-LSTMs, where each stack element is itself based on a compositional representation of parse trees.  #b24  encode each tree node as two compositional representations capturing the inside and outside structures around the node, and feed the representations into a reranker. A similar reranking approach, this time based on convolutional neural networks, is taken by  #b45 . Finally, in  #b18  we present an Easy-First parser based on a novel hierarchical-LSTM tree encoding.In contrast to these, the approach we present in this work results in much simpler feature functions, without resorting to elaborate network architectures or compositional tree representations.Work by  #b41  employs a sequence-to-sequence with attention architecture for constituency parsing. Each token in the input sentence is encoded in a deep-BiLSTM representation, and then the tokens are fed as input to a deep-LSTM that predicts a sequence of bracketing actions based on the already predicted bracketing as well as the encoded BiLSTM vectors. A trainable attention mechanism is used to guide the parser to relevant BiLSTM vectors at each stage. This architecture shares with ours the use of BiLSTM encoding and end-to-end training. The sequence of bracketing actions can be interpreted as a sequence of Shift and Reduce operations of a transition-based parser. However, while the parser of Vinyals et al. relies on a trainable attention mechanism for focusing on specific BiLSTM vectors, parsers in the transition-based family we use in Section 4 use a human designed stack and buffer mechanism to manually direct the parser's attention. While the effectiveness of the trainable attention approach is impressive, the stack-and-buffer guidance of transitionbased parsers results in more robust learning. Indeed, work by Cross and Huang (2016), published while working on the camera-ready version of this paper, show that the same methodology as ours is highly effective also for greedy, transition-based constituency parsing, surpassing the beam-based architecture of Vinyals et al. (88.3F vs. 89.8F points) when trained on the Penn Treebank dataset and without using orthogonal methods such as ensembling and up-training.",
        "Bidirectional Recurrent Neural Networks": "Recurrent neural networks (RNNs) are statistical learners for modeling sequential data. An RNN allows one to model the ith element in the sequence based on the past -the elements x 1:i up to and including it. The RNN model provides a framework for conditioning on the entire history x 1:i without resorting to the Markov assumption which is traditionally used for modeling sequences. RNNs were shown to be capable of learning to count, as well as to model line lengths and complex phenomena such as bracketing and code indentation  #b16 . Our proposed feature extractors are based on a bidirectional recurrent neural network (BiRNN), an extension of RNNs that take into account both the past x 1:i and the future x i:n . We use a specific flavor of RNN called a long short-term memory network (LSTM). For brevity, we treat RNN as an abstraction, without getting into the mathematical details of the implementation of the RNNs and LSTMs. For further details on RNNs and LSTMs, the reader is referred to  #b10  and  #b3 .The recurrent neural network (RNN) abstraction is a parameterized function RNN \u03b8 (x 1:n ) mapping a sequence of n input vectors x 1:n , x i \u2208 R d in to a sequence of n output vectors h 1:n , h i \u2208 R dout . Each output vector h i is conditioned on all the input vectors x 1:i , and can be thought of as a summary of the prefix x 1:i of x 1:n . In our notation, we ignore the intermediate vectors h 1:n-1 and take the output of RNN \u03b8 (x 1:n ) to be the vector h n .A bidirectional RNN is composed of two RNNs, RNN F and RNN R , one reading the sequence in its regular order, and the other reading it in reverse. Concretely, given a sequence of vectors x 1:n and a desired index i, the function BIRNN \u03b8 (x 1:n , i) is defined as:BIRNN \u03b8 (x 1:n , i) = RNN F (x 1:i ) \u2022 RNN R (x n:i )The vector v i = BIRNN(x 1:n , i) is then a representation of the ith item in x 1:n , taking into account both the entire history x 1:i and the entire future x i:n by concatenating the matching RNNs. We can view the BiRNN encoding of an item i as representing the item i together with a context of an infinite window around it.Computational Complexity Computing the BiRNN vectors encoding of the ith element of a sequence x 1:n requires O(n) time for computing the two RNNs and concatenating their outputs. A naive approach of computing the bidirectional representation of all n elements result in O(n 2 ) computation. However, it is trivial to compute the BiRNN encoding of all sequence items in linear time by pre-computing RNN F (x 1:n ) and RNN R (x n:1 ), keeping the intermediate representations, and concatenating the required elements as needed.BiRNN Training Initially, the BiRNN encodings v i do not capture any particular information. During training, the encoded vectors v i are fed into further network layers, until at some point a prediction is made, and a loss is incurred. The back-propagation algorithm is used to compute the gradients of all the parameters in the network (including the BiRNN parameters) with respect to the loss, and an optimizer is used to update the parameters according to the gradients. The training procedure causes the BiRNN function to extract from the input sequence x 1:n the relevant information for the task task at hand.",
        "Going deeper We use a variant of deep": "bidirectional RNN (or k-layer BiRNN) which is composed of k BiRNN functions BIRNN 1 , \u2022 \u2022 \u2022 , BIRNN k that feed into each other: the output BIRNN (x 1:n , 1), . . . , BIRNN (x 1:n , n) of BIRNN becomes the input of BIRNN +1 . StackingBiRNNs in this way has been empirically shown to be effective  #b14 . In this work, we use BiRNNs and deep-BiRNNs interchangeably, specifying the number of layers when needed.Historical Notes RNNs were introduced by Elman (1990), and extended to BiRNNs by  #b36 . The LSTM variant of RNNs is due to  #b12 . BiLSTMs were recently popularized by  #b11 , and deep BiRNNs were introduced to NLP by  #b14 , who used them for sequence tagging. In the context of parsing,  #b27  and  #b40  use a BiLSTM sequence tagging model to assign a CCG supertag for each token in the sentence.  #b27  feeds the resulting supertags sequence into an A* CCG parser.  #b40  adds an additional layer of LSTM which receives the BiLSTM representation together with the k-best supertags for each word and outputs the most likely supertag given previous tags, and then feeds the predicted supertags to a discriminitively trained parser. In both works, the BiLSTM is trained to produce accurate CCG supertags, and is not aware of the global parsing objective.",
        "Our Approach": "We propose to replace the hand-crafted feature functions in favor of minimally-defined feature functions which make use of automatically learned Bidirectional LSTM representations.Given n-words input sentence s with words w 1 , . . . , w n together with the corresponding POS tags t 1 , . . . , t n ,4 we associate each word w i and POS t i with embedding vectors e(w i ) and e(t i ), and create a sequence of input vectors x 1:n in which each x i is a concatenation of the corresponding word and POS vectors:x i = e(w i ) \u2022 e(p i )The embeddings are trained together with the model. This encodes each word in isolation, disregarding its context. We introduce context by representing each input element as its (deep) BiLSTM vector, v i :v i = BILSTM(x 1:n , i)Our feature function \u03c6 is then a concatenation of a small number of BiLSTM vectors. The exact feature function is parser dependent and will be discussed when discussing the corresponding parsers. The resulting feature vectors are then scored using a non-linear function, namely a multi-layer perceptron with one hidden layer (MLP):M LP \u03b8 (x) = W 2 \u2022 tanh(W 1 \u2022 x + b 1 ) + b 2 where \u03b8 = {W 1 , W 2 , b 1 , b 2 } are the model parame- ters.Beside using the BiLSTM-based feature functions, we make use of standard parsing techniques. Crucially, the BiLSTM is trained jointly with the rest of the parsing objective. This allows it to learn representations which are suitable for the parsing task.Consider a concatenation of two BiLSTM vectors (v i \u2022 v j ) scored using an MLP. The scoring function has access to the words and POS-tags of v i and v j , as well as the words and POS-tags of the words in an infinite window surrounding them. As LSTMs are known to capture length and sequence position information, it is very plausible that the scoring function can be sensitive also to the distance between i and j, their ordering, and the sequential material between them.Parsing-time Complexity Once the BiLSTM is trained, parsing is performed by first computing the BiLSTM encoding v i for each word in the sentence (a linear time operation). 5 Then, parsing proceeds as usual, where the feature extraction involves a concatenation of a small number of the pre-computed v i vectors.",
        "Transition-based Parser": "We begin by integrating the feature extractor in a transition-based parser  #b34 . We follow the notation in  #b9 . The Scoring:LST M f xthe concat LST M f xbrown concat LST M f xfox concat LST M f xjumped concat LST M f xover concat LST M f xthe concat LST M f xlazy concat LST M f xdog concat LST M f xROOT concat LST M b s0 LST M b s1 LST M b s2 LST M b s3 LST M b s4 LST M b s5 LST M b s6 LST M b s7 LST M b s8 Vthe Vbrown Vfox Vjumped Vover Vthe Vlazy Vdog VROOT MLP (ScoreLeftArc, ScoreRightArc, ScoreShift)Figure 1: Illustration of the neural model scheme of the transition-based parser when calculating the scores of the possible transitions in a given configuration. The configuration (stack and buffer) is depicted on the top. Each transition is scored using an MLP that is fed the BiLSTM encodings of the first word in the buffer and the three words at the top of the stack (the colors of the words correspond to colors of the MLP inputs above), and a transition is picked greedily. Each x i is a concatenation of a word and a POS vector, and possibly an additional external embedding vector for the word. The figure depicts a single-layer BiLSTM, while in practice we use two layers. When parsing a sentence, we iteratively compute scores for all possible transitions and apply the best scoring action until the final configuration is reached.transition-based parsing framework assumes a transition system, an abstract machine that processes sentences and produces parse trees. The transition system has a set of configurations and a set of transitions which are applied to configurations. When parsing a sentence, the system is initialized to an initial configuration based on the input sentence, and transitions are repeatedly applied to this configuration. After a finite number of transitions, the system arrives at a terminal configuration, and a parse tree is read off the terminal configuration. In a greedy parser, a classifier is used to choose the transition to take in each configuration, based on features extracted from the configuration itself. The parsing algorithm is presented in Algorithm 1 below.Given a sentence s, the parser is initialized with the configuration c (line 2). Then, a feature function \u03c6(c) represents the configuration c as a vector, which is fed to a scoring function SCORE assigning scores to (configuration,transition) pairs. SCORE c \u2190 t(c) 6: return tree(c) scores the possible transitions t, and the highest scoring transition t is chosen (line 4). The transition t is applied to the configuration, resulting in a new parser configuration. The process ends when reaching a final configuration, from which the resulting parse tree is read and returned (line 6).Transition systems differ by the way they define configurations, and by the particular set of transitions available to them. A parser is determined by the choice of a transition system, a feature function \u03c6 and a scoring function SCORE. Our choices are detailed below.The Arc-Hybrid System Many transition systems exist in the literature. In this work, we use the archybrid transition system  #b22 , which is similar to the more popular arc-standard system  #b33 , but for which an efficient dynamic oracle is available  #b8  #b9 . In the arc-hybrid system, a configuration c = (\u03c3, \u03b2, T ) consists of a stack \u03c3, a buffer \u03b2, and a set T of dependency arcs. Both the stack and the buffer hold integer indices pointing to sentence elements. Given a sentence s = w 1 , . . . , w n , t 1 , . . . , t n , the system is initialized with an empty stack, an empty arc set, and \u03b2 = 1, . . . , n, ROOT , where ROOT is the special root index. Any configuration c with an empty stack and a buffer containing only ROOT is terminal, and the parse tree is given by the arc set T c of c. The archybrid system allows 3 possible transitions, SHIFT, LEFT and RIGHT , defined as:SHIFT[(\u03c3, b 0 |\u03b2, T )] = (\u03c3|b 0 , \u03b2, T ) LEFT [(\u03c3|s 1 |s 0 , b 0 |\u03b2, T )] = (\u03c3|s 1 , b 0 |\u03b2, T \u222a {(b 0 , s 0 , )}) RIGHT [(\u03c3|s 1 |s 0 , \u03b2, T )] = (\u03c3|s 1 , \u03b2, T \u222a {(s 1 , s 0 , )})The SHIFT transition moves the first item of the buffer (b 0 ) to the stack. The LEFT transition removes the first item on top of the stack (s 0 ) and attaches it as a modifier to b 0 with label , adding the arc (b 0 , s 0 , ). The RIGHT transition removes s 0 from the stack and attaches it as a modifier to the next item on the stack (s 1 ), adding the arc (s 1 , s 0 , ). ",
        "Scoring Function": "\u03c6(c) = v s 2 \u2022 v s 1 \u2022 v s 0 \u2022 v b 0 v i = BILSTM(x 1:n , i)This feature function is rather minimal: it takes into account the BiLSTM representations of s 1 , s 0 and b 0 , which are the items affected by the possible transitions being scored, as well as one extra stack context s 2 .6 Figure 1 depicts transition scoring with our architecture and this feature function. Note that, unlike previous work, this feature function does not take into account T , the already built structure. The high parsing accuracies in the experimental sections suggest that the BiLSTM encoding is capable of estimating a lot of the missing information based on the provided stack and buffer elements and the sequential content between them.While not explored in this work, relying on only four word indices for scoring an action results in very compact state signatures, making our proposed feature representation very appealing for use in transition-based parsers that employ dynamic-programming search  #b13  #b22 .Extended Feature Function One of the benefits of the greedy transition-based parsing framework is precisely its ability to look at arbitrary features from the already built tree. If we allow somewhat less minimal feature function, we could add the BiLSTM vectors corresponding to the right-most and leftmost modifiers of s 0 , s 1 and s 2 , as well as the leftmost modifier of b 0 , reaching a total of 11 BiLSTM vectors. We refer to this as the extended feature set. As we'll see in Section 6, using the extended set does indeed improve parsing accuracies when using pre-trained word embeddings, but has a minimal effect in the fully-supervised case.7 ",
        "Details of the Training Algorithm": "The training objective is to set the score of correct transitions above the scores of incorrect transitions. We use a margin-based objective, aiming to maximize the margin between the highest scoring correct action and the highest scoring incorrect action. The hinge loss at each parsing configuration c is defined as:max 0, 1-max to\u2208G M LP \u03c6(c) [t o ] + max tp\u2208A\\G M LP \u03c6(c) [t p ]where A is the set of possible transitions and G is the set of correct (gold) transitions at the current stage. At each stage of the training process the parser scores the possible transitions A, incurs a loss, selects a transition to follow, and moves to the next configuration based on it. The local losses are summed throughout the parsing process of a sentence, and the parameters are updated with respect to the sum of the losses at sentence boundaries. 8The gradients of the entire network (including the MLP and the BiLSTM) with respect to the sum of the losses are calculated using the backpropagation algorithm. As usual, we perform several training iterations over the training corpus, shuffling the order of sentences in each iteration.",
        "Error-Exploration and Dynamic Oracle Training": "We follow  #b9 ;  #b8  in using error exploration training with a dynamic-oracle, which we briefly describe below.At each stage in the training process, the parser assigns scores to all the possible transitions t \u2208 A. It then selects a transition, applies it, and moves to the next step. Which transition should be followed? A common approach follows the highest scoring transition that can lead to the gold tree. However, when training in this way the parser sees only configurations that result from following correct actions, and as a result tends to suffer from error propagation at test time. Instead, in error-exploration training the parser follows the highest scoring action in A during training even if this action is incorrect, exposing it to configurations that result from erroneous decisions. This strategy requires defining the set G such that the correct actions to take are well-defined also for states that cannot lead to the gold tree. Such a set G is called a dynamic oracle. We perform error-exploration training using the dynamic-oracle defined by  #b9 .Aggressive Exploration We found that even when using error-exploration, after one iteration the model remembers the training set quite well, and does not make enough errors to make error-exploration effective. In order to expose the parser to more errors, we follow an aggressive-exploration scheme: we sometimes follow incorrect transitions also if they score below correct transitions. Specifically, when the score of the correct transition is greater than that of the wrong transition but the difference is smaller than a margin constant, we chose to follow the incorrect action with probability p agg (we use p agg = 0.1 in our experiments).Summary The greedy transition-based parser follows standard techniques from the literature (margin-based objective, dynamic oracle training, error exploration, MLP-based non-linear scoring function). We depart from the literature by replacing the hand-crafted feature function over carefully selected components of the configuration with a concatenation of BiLSTM representations of a few prominent items on the stack and the buffer, and training the BiLSTM encoder jointly with the rest of the network.",
        "Graph-based Parser": "Graph-based parsing follows the common structured prediction paradigm  #b37  #b31 :predict(s) = arg max y\u2208Y(s) score global (s, y) score global (s, y) = part\u2208y score local (s, part)Given an input sentence s (and the corresponding sequence of vectors x 1:n ) we look for the highest-LST M f x the concat LST M f x brown concat LST M f x fox concat LST M f x jumped concat LST M f x * concat LST M b s 0 LST M b s 1 LST M b s 2 LST M b s 3 LST M b s 4 V the V brown V fox V jumped V * M LP M LP M LP M LP + Figure 2:Illustration of the neural model scheme of the graph-based parser when calculating the score of a given parse tree. The parse tree is depicted below the sentence. Each dependency arc in the sentence is scored using an MLP that is fed the BiLSTM encoding of the words at the arc's end points (the colors of the arcs correspond to colors of the MLP inputs above), and the individual arc scores are summed to produce the final score. All the MLPs share the same parameters. The figure depicts a single-layer BiLSTM, while in practice we use two layers. When parsing a sentence, we compute scores for all possible n 2 arcs, and find the best scoring tree using a dynamic-programming algorithm.scoring parse tree y in the space Y(s) of valid dependency trees over s. In order to make the search tractable, the scoring function is decomposed to the sum of local scores for each part independently.In this work, we focus on arc-factored graph based approach presented in  #b31 . Arc-factored parsing decomposes the score of a tree to the sum of the score of its head-modifier arcs (h, m):parse(s) = arg max y\u2208Y(s) (h,m)\u2208y score \u03c6(s, h, m)Given the scores of the arcs the highest scoring projective tree can be efficiently found using Eisner's decoding algorithm (1996). McDonald et al. and most subsequent work estimate the local score of an arc by a linear model parameterized by a weight vector w, and a feature function \u03c6(s, h, m) assigning a sparse feature vector for an arc linking modifier m to head h. We follow  #b35  and replace the linear scoring function with an MLP.The feature extractor \u03c6(s, h, m) is usually complex, involving many elements (see Section 2.1). In contrast, our feature extractor uses merely the BiLSTM encoding of the head word and the mod-ifier word:\u03c6(s, h, m) = BIRNN(x 1:n , h) \u2022 BIRNN(x 1:n , m)The final model is:parse(s) = arg max y\u2208Y(s) score global (s, y) = arg max y\u2208Y(s) (h,m)\u2208y score \u03c6(s, h, m) = arg max y\u2208Y(s) (h,m)\u2208y M LP (v h \u2022 v m ) v i = BIRNN(x 1:n , i)The architecture is illustrated in Figure 2.Training The training objective is to set the score function such that correct tree y is scored above incorrect ones. We use a margin-based objective (Mc-Donald et al., 2005; #b25 , aiming to maximize the margin between the score of the gold tree y and the highest scoring incorrect tree y . We define a hinge loss with respect to a gold tree y as:max 0, 1 -max y =y (h,m)\u2208y M LP (v h \u2022 v m ) + (h,m)\u2208y M LP (v h \u2022 v m )Each of the tree scores is then calculated by activating the MLP on the arc representations. The entire loss can viewed as the sum of multiple neural networks, which is sub-differentiable. We calculate the gradients of the entire network (including to the BiLSTM encoder and word embeddings).Labeled Parsing Up to now, we described unlabeled parsing. A possible approach for adding labels is to score the combination of an unlabeled arc (h, m) and its label by considering the label as part of the arc (h, m, ). This results in |Labels|\u00d7|Arcs| parts that need to be scored, leading to slow parsing speeds and arguably a harder learning problem. Instead, we chose to first predict the unlabeled structure using the model given above, and then predict the label of each resulting arc. Using this approach, the number of parts stays small, enabling fast parsing.The labeling of an arc (h, m) is performed using the same feature representation \u03c6(s, h, m) fed into a different MLP predictor:label(h, m) = arg max \u2208labels M LP LBL (v h \u2022 v m )[ ]As before we use a margin based hinge loss. The labeler is trained on the gold trees. 9 The BiLSTM encoder responsible for producing v h and v m is shared with the arc-factored parser: the same BiLSTM encoder is used in the parer and the labeler. This sharing of parameters can be seen as an instance of multi-task learning (Caruana, 1997). As we show in Section 6, the sharing is effective: training the BiLSTM feature encoder to be good at predicting arc-labels significantly improves the parser's unlabeled accuracy.",
        "Loss augmented inference": "In initial experiments, the network learned quickly and overfit the data. In order to remedy this, we found it useful to use loss augmented inference  #b37 . The intuition behind loss augmented inference is to update against trees which have high model scores and are also very wrong. This is done by augmenting the score of each part not belonging to the gold tree by adding a constant to its score. Formally, the loss transforms as follows: max(0, 1 + score(x, y)max y =y part\u2208y (score local (x, part) + 1 part \u2208y ))",
        "Speed improvements": "The arc-factored model requires the scoring of n 2 arcs. Scoring is performed using an MLP with one hidden layer, resulting in n 2 matrix-vector multiplications from the input to the hidden layer, and n 2 multiplications from the hidden to the output layer. The first n 2 multiplications involve larger dimensional input and output vectors, and are the most time consuming. Fortunately, these can be reduced to 2n multiplications and n 2 vector additions, by observing that the multiplicationW \u2022 (v h \u2022 v m ) can be written as W 1 \u2022 v h + W 2 \u2022 v mwhere W 1 and W 1 are are the first and second half of the matrix W and reusing the products across different pairs. Summary The graph-based parser is straightforward first-order parser, trained with a marginbased hinge-loss and loss-augmented inference. We depart from the literature by replacing the handcrafted feature function with a concatenation of BiLSTM representations of the head and modifier words, and training the BiLSTM encoder jointly with the structured objective. We also introduce a novel multi-task learning approach for labeled parsing by training a second-stage arc-labeler sharing the same BiLSTM encoder with the unlabeled parser.",
        "Experiments and Results": "We evaluated our parsing model on English and Chinese data. For comparison purposes we follow the setup of  #b5 .Data For English, we used the Stanford Dependency (SD) (de Marneffe and Manning, 2008) conversion of the Penn Treebank  #b28   #b42 ; Pei15:  #b35 ; Dyer15  #b5 ; Ballesteros16  #b0 ; LeZuidema14 (Le and Zuidema, 2014); Zhu15:  #b45 .same predicted POS-tags as used in  #b5 ;  #b1 . This dataset contains a few non-projective trees. Punctuation symbols are excluded from the evaluation.For Chinese, we use the Penn Chinese Treebank 5.1 (CTB5), using the train/test/dev splits of  #b43  #b5  with gold partof-speech tags, also following  #b5  #b1 .When using external word embeddings, we also use the same data as  #b5 . 10   Implementation Details The parsers are implemented in python, using the PyCNN toolkit 11 for neural network training. The code is available at the github repository https://github.com/ elikip/bist-parser. We use the LSTM variant implemented in PyCNN, and optimize using the Adam optimizer  #b17 . Unless otherwise noted, we use the default values provided by PyCNN (e.g. for random initialization, learning rates etc). 10 We thank Dyer et al. for sharing their data with us. 11 https://github.com/clab/cnn/tree/ master/pycnnThe word and POS embeddings e(w i ) and e(p i ) are initialized to random values and trained together with the rest of the parsers' networks. In some experiments, we introduce also pre-trained word embeddings. In those cases, the vector representation of a word is a concatenation of its randomlyinitialized vector embedding with its pre-trained word vector. Both are tuned during training. We use the same word vectors as in  #b5  During training, we employ a variant of word dropout  #b15 , and replace a word with the unknown-word symbol with probability that is inversely proportional to the frequency of the word. A word w appearing #(w) times in the training corpus is replaced with the unknown symbol with probability p unk (w) = \u03b1 #(w)+\u03b1 . If a word was dropped the external embedding of the word is also dropped with probability 0.5.We train the parsers for up to 30 iterations, and choose the best model according to the UAS accuracy on the development set.Hyperparameter Tuning We performed a very minimal hyper-parameter search with the graph-based parser, and use the same hyper-parameters for both parsers. The hyper-parameters of the final networks used for all the reported experiments are detailed in Table 2.  It is clear that our parsers are very competitive, despite using very simple parsing architectures and minimal feature extractors. When not using external embeddings, the first-order graph-based parser with 2 features outperforms all other systems that are not using external resources, including the third-order TurboParser. The greedy transition based parser with 4 features also matches or outperforms most other parsers, including the beam-based transition parser with heavily engineered features of  #b44  and the Stack-LSTM parser of  #b5 , as well as the same parser when trained using a dynamic oracle  #b0 . Moving from the simple (4 features) to the extended (11 features) feature set leads to some gains in accuracy for both English and Chinese.Interestingly, when adding external word embeddings the accuracy of the graph-based parser degrades. We are not sure why this happens, and leave the exploration of effective semi-supervised parsing with the graph-based model for future work. The greedy parser does manage to benefit from the external embeddings, and using them we also see gains from moving from the simple to the extended feature set. Both feature sets result in very competitive re-12 Unfortunately, many papers still report English parsing results on the deficient Yamada and Matsumoto head rules (PTB-YM) rather than the more modern Stanford-dependencies (PTB-SD). We note that the PTB-YM and PTB-SD results are not strictly comparable, and in our experience the PTB-YM results are usually about half a UAS point higher.sults, with the extended feature set yielding the best reported results for Chinese, and ranked second for English, after the heavily-tuned beam-based parser of  #b42 .",
        "Additional Results": "We perform some ablation experiments in order to quantify the effect of the different components on our best models (Table 3 Loss augmented inference is crucial for the success of the graph-based parser, and the multi-task learning scheme for the arc-labeler contributes nicely to the unlabeled scores. Dynamic oracle training yields nice gains for both English and Chinese.",
        "Conclusion": "We presented a pleasingly effective approach for feature extraction for dependency parsing based on a BiLSTM encoder that is trained jointly with the parser, and demonstrated its effectiveness by integrating it into two simple parsing models: a greedy transition-based parser and a globally optimized first-order graph-based parser, yielding very competitive parsing accuracies in both cases."
    },
    {
        "1": "Structured training of sequence tagging models over RNNbased representations was explored by Chiu and Nichols (2016) and Lample et al. (2016).",
        "2": "http://www.seas.upenn.edu/~strctlrn/ MSTParser/MSTParser.html",
        "3": "In all of these neural-network based approaches, the vector representations of words were initialized using pre-trained word-embeddings derived from a large corpus external to the training data. This puts the approaches in the semi-supervised category, making it hard to tease apart the contribution of the automatic feature-combination component from that of the semisupervised component.",
        "316": "Downloaded from http://www.mitpressjournals.org/doi/pdf/10.1162/tacl_a_00101 by guest on 21 November 2023",
        "4": "In this work the tag sequence is assumed to be given, and in practice is predicted by an external model. Future work will address relaxing this assumption.",
        "5": "While the BiLSTM computation is quite efficient as it is, as demonstrated byLewis et al. (2016), if using a GPU implementation the BiLSTM encoding can be efficiently performed over many of sentences in parallel, making its computation cost almost negligible.",
        "6": "An additional buffer context is not needed, as b1 is by definition adjacent to b0, a fact that we expect the BiLSTM encoding of b0 to capture. In contrast, b0, s0, s1 and s2 are not necessarily adjacent to each other in the original",
        "7": "sentence.7  We did not experiment with other feature configurations. It is well possible that not all of the additional 7 child encodings are needed for the observed accuracy gains, and that a smaller feature set will yield similar or even better improvements.",
        "8": "To increase gradient stability and training speed, we simulate mini-batch updates by only updating the parameters when the sum of local losses contains at least 50 non-zero elements. Sums of fewer elements are carried across sentences. This assures us a sufficient number of gradient samples for every update thus minimizing the effect of gradient instability.",
        "9": "When training the labeled parser, we calculate the structure loss and the labeling loss for each training sentence, and sum the losses prior to computing the gradients."
    },
    {
        "b0": [
            "Training with exploration improves a greedy stack-LSTM parser",
            "",
            "",
            "",
            "Ballesteros",
            "Goldberg",
            "Dyer",
            "Smith"
        ],
        "b1": [
            "A fast and accurate dependency parser using neural networks",
            "",
            "",
            "",
            "Chen",
            "Manning"
        ],
        "b2": [
            "",
            "",
            "Named entity recognition with bidirectional LSTM-CNNs",
            ""
        ],
        "b3": [
            "Incremental parsing with minimal features using bi-directional LSTM",
            "",
            "",
            "",
            "Cho"
        ],
        "b4": [
            "",
            "",
            "Stanford dependencies manual",
            ""
        ],
        "b5": [
            "Transitionbased dependency parsing with stack long short-term memory",
            "",
            "",
            "",
            "Dyer",
            "Ballesteros",
            "Ling",
            "Matthews",
            "Smith"
        ],
        "b6": [
            "Three new probabilistic models for dependency parsing: An exploration",
            "",
            "",
            "",
            "Eisner"
        ],
        "b7": [
            "Finding structure in time",
            "",
            "",
            "",
            "Elman"
        ],
        "b8": [
            "A dynamic oracle for arc-eager dependency parsing",
            "",
            "",
            "",
            "Goldberg",
            "Nivre"
        ],
        "b9": [
            "Training deterministic parsers with non-deterministic oracles",
            "",
            "",
            "",
            "Goldberg",
            "Nivre"
        ],
        "b10": [
            "",
            "",
            "A primer on neural network models for natural language processing",
            ""
        ],
        "b11": [
            "",
            "",
            "Supervised sequence labelling with recurrent neural networks",
            ""
        ],
        "b12": [
            "Long short-term memory",
            "",
            "",
            "",
            "Hochreiter",
            "Schmidhuber"
        ],
        "b13": [
            "Dynamic programming for linear-time incremental parsing",
            "",
            "",
            "",
            "Huang",
            "Sagae"
        ],
        "b14": [
            "Opinion mining with deep recurrent neural networks",
            "",
            "",
            "",
            "Irsoy",
            "Cardie"
        ],
        "b15": [
            "Deep unordered composition rivals syntactic methods for text classification",
            "",
            "",
            "",
            "Iyyer",
            "Manjunatha",
            "Boyd-Graber",
            "Daum\u00e9"
        ],
        "b16": [
            "",
            "",
            "Visualizing and understanding recurrent networks",
            ""
        ],
        "b17": [
            "Adam: A method for stochastic optimization",
            "",
            "",
            "",
            "Diederik",
            "Kingma",
            "Ba"
        ],
        "b18": [
            "",
            "",
            "",
            ""
        ],
        "b19": [
            "Easy-first dependency parsing with hierarchical tree LSTMs. Transactions of the Association for Computational Linguistics, 4. To appear",
            "",
            "",
            ""
        ],
        "b20": [
            "Simple semi-supervised dependency parsing",
            "",
            "",
            "",
            "Koo",
            "Carreras",
            "Collins"
        ],
        "b21": [
            "",
            "",
            "Dependency Parsing. Synthesis Lectures on Human Language Technologies",
            ""
        ],
        "b22": [
            "Dynamic programming algorithms for transition-based dependency parsers",
            "",
            "",
            "",
            "Kuhlmann",
            "G\u00f3mez-Rodr\u00edguez",
            "Satta"
        ],
        "b23": [
            "Neural architectures for named entity recognition",
            "",
            "",
            "",
            "Lample",
            "Ballesteros",
            "Subramanian",
            "Kawakami",
            "Dyer"
        ],
        "b24": [
            "The insideoutside recursive neural network model for dependency parsing",
            "",
            "",
            "",
            "Le",
            "Zuidema"
        ],
        "b25": [
            "A tutorial on energy-based learning",
            "",
            "",
            "",
            "Lecun",
            "Chopra",
            "Hadsell",
            "Ranzato",
            "Huang"
        ],
        "b26": [
            "Low-rank tensors for scoring dependency structures",
            "",
            "",
            "",
            "Lei",
            "Xin",
            "Zhang",
            "Barzilay",
            "Jaakkola"
        ],
        "b27": [
            "LSTM CCG parsing",
            "",
            "",
            "",
            "Lewis",
            "Lee",
            "Zettlemoyer"
        ],
        "b28": [
            "Building a large annotated corpus of English: The Penn Treebank",
            "",
            "",
            "",
            "Marcus",
            "Santorini",
            "Marcinkiewicz"
        ],
        "b29": [
            "Concise integer linear programming formulations for dependency parsing",
            "",
            "",
            "",
            "Martins",
            "Smith",
            "Xing"
        ],
        "b30": [
            "Turning on the turbo: Fast third-order nonprojective turbo parsers",
            "",
            "",
            "",
            "Martins",
            "Almeida",
            "Smith"
        ],
        "b31": [
            "Online large-margin training of dependency parsers",
            "",
            "",
            "",
            "Mcdonald",
            "Crammer",
            "Pereira"
        ],
        "b32": [
            "",
            "",
            "Discriminative Training and Spanning Tree Algorithms for Dependency Parsing",
            ""
        ],
        "b33": [
            "Incrementality in deterministic dependency parsing",
            "",
            "",
            "",
            "Nivre"
        ],
        "b34": [
            "Algorithms for deterministic incremental dependency parsing",
            "",
            "",
            "",
            "Nivre"
        ],
        "b35": [
            "An effective neural network model for graph-based dependency parsing",
            "",
            "",
            "",
            "Pei",
            "Ge",
            "Chang"
        ],
        "b36": [
            "Bidirectional recurrent neural networks",
            "",
            "",
            "",
            "Schuster",
            "Paliwal"
        ],
        "b37": [
            "Learning structured prediction models: A large margin approach",
            "",
            "",
            "",
            "Taskar",
            "Chatalbashev",
            "Koller",
            "Guestrin"
        ],
        "b38": [
            "Template kernels for dependency parsing",
            "",
            "",
            "",
            "Taub-Tabib",
            "Goldberg",
            "Globerson"
        ],
        "b39": [
            "A latent variable model for generative dependency parsing",
            "",
            "",
            "",
            "Titov",
            "Henderson"
        ],
        "b40": [
            "Supertagging with LSTMs",
            "",
            "",
            "",
            "Vaswani",
            "Bisk",
            "Sagae",
            "Musa"
        ],
        "b41": [
            "Grammar as a foreign language",
            "",
            "",
            "",
            "Vinyals",
            "Kaiser",
            "Koo",
            "Petrov",
            "Sutskever",
            "Hinton"
        ],
        "b42": [
            "Structured training for neural network transition-based parsing",
            "",
            "",
            "",
            "Weiss",
            "Alberti",
            "Collins",
            "Petrov"
        ],
        "b43": [
            "A tale of two parsers: Investigating and combining graph-based and transition-based dependency parsing",
            "",
            "",
            "",
            "Zhang",
            "Clark"
        ],
        "b44": [
            "Transition-based dependency parsing with rich non-local features",
            "",
            "",
            "",
            "Zhang",
            "Nivre"
        ],
        "b45": [
            "A re-ranking model for dependency parser with recursive convolutional neural network",
            "",
            "",
            "",
            "Zhu",
            "Qiu",
            "Chen",
            "Huang"
        ]
    },
    {
        "tab_1": "Table 1 :1, using the standard train/dev/test splits with the Test-set parsing results of various state-of-the-art parsing systems on the English (PTB) and Chinese (CTB) datasets. The systems that use embeddings may use different pre-trained embeddings. English results use predicted POS tags (different systems use different taggers), while Chinese results use gold POS tags. PTB-YM: English PTB, Yamada and Matsumoto head rules. PTB-SD: English PTB, Stanford Dependencies (different systems may use different versions of the Stanford converter). CTB: Chinese Treebank. reranking /blend in Method column indicates a reranking system where the reranker score is interpolated with the base-parser's score. The different systems and the numbers reported from them are taken from: ZhangNivre11: (Zhang and Nivre, 2011); Martins13: (Martins et al., 2013); Weiss15SystemMethodRepresentationEmb PTB-YMPTB-SDCTBUASUAS LAS UAS LASThis work This workgraph, 1st order transition (greedy, dyn-oracle)2 BiLSTM vectors 4 BiLSTM vectors----93.1 91.0 86.6 85.1 93.1 91.0 86.2 85.0This worktransition (greedy, dyn-oracle)11 BiLSTM vectors--93.2 91.2 86.5 84.9ZhangNivre11transition (beam)large feature set (sparse)-92.9--86.0 84.4Martins13 (TurboParser)graph, 3rd order+large feature set (sparse)-92.893.1---Pei15graph, 2nd orderlarge feature set (dense)-93.0----Dyer15transition (greedy)Stack-LSTM + composition--92.4 90.0 85.7 84.1Ballesteros16transition (greedy, dyn-oracle) Stack-LSTM + composition--92.7 90.6 86.1 84.5This workgraph, 1st order2 BiLSTM vectorsYES-93.0 90.9 86.5 84.9This worktransition (greedy, dyn-oracle)4 BiLSTM vectorsYES-93.6 91.5 87.4 85.9This worktransition (greedy, dyn-oracle)11 BiLSTM vectorsYES-93.9 91.9 87.6 86.1Weiss15transition (greedy)large feature set (dense)YES-93.2 91.2--Weiss15 Pei15transition (beam) graph, 2nd orderlarge feature set (dense) large feature set (dense)YES YES-93.394.0 92.0 ------Dyer15transition (greedy)Stack-LSTM + composition YES-93.1 90.9 87.1 85.5Ballesteros16 LeZuidema14transition (greedy, dyn-oracle) Stack-LSTM + composition YES reranking /blend inside-outside recursive net YES-93.193.6 91.4 87.6 86.2 93.8 91.5 --Zhu15reranking /blendrecursive conv-netYES93.8--85.7-",
        "tab_2": "Table 2 :2Hyper-parameter values used in experimentsMain Results Table1lists the test-set accuracies of our best parsing models, compared to other state-ofthe-art parsers from the literature.12  ",
        "tab_3": "Table 3 :3). Ablation experiments results (dev set) for the graphbased parser without external embeddings and the greedy parser with external embeddings and extended feature set.PTBCTBUAS LAS UAS LASGraph (no ext. emb) 93.3 91.0 87.0 85.4-POS92.9 89.8 80.6 76.8-ArcLabeler92.7-86.2--Loss Aug.81.3 79.4 52.6 51.7Greedy (ext. emb)93.8 91.5 87.8 86.0-POS93.4 91.2 83.4 81.6-DynOracle93.5 91.4 87.5 85.9"
    }
]