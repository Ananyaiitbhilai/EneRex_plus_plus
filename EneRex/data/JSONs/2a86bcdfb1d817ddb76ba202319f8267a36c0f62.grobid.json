[
    {
        "basename": "2a86bcdfb1d817ddb76ba202319f8267a36c0f62.grobid",
        "fulltext": 36,
        "footnote_size": 0,
        "reference": 66,
        "authors": [
            "Tang",
            "Wang",
            "Bai",
            "Shen",
            "Liu",
            "Yuille"
        ]
    },
    {
        "title": "PCL: Proposal Cluster Learning for Weakly Supervised Object Detection",
        "abstract": "Weakly Supervised Object Detection (WSOD), using only image-level annotations to train object detectors, is of growing importance in object recognition. In this paper, we propose a novel deep network for WSOD. Unlike previous networks that transfer the object detection problem to an image classification problem using Multiple Instance Learning (MIL), our strategy generates proposal clusters to learn refined instance classifiers by an iterative process. The proposals in the same cluster are spatially adjacent and associated with the same object. This prevents the network from concentrating too much on parts of objects instead of whole objects. We first show that instances can be assigned object or background labels directly based on proposal clusters for instance classifier refinement, and then show that treating each cluster as a small new bag yields fewer ambiguities than the directly assigning label method. The iterative instance classifier refinement is implemented online using multiple streams in convolutional neural networks, where the first is an MIL network and the others are for instance classifier refinement supervised by the preceding one. Experiments are conducted on the PASCAL VOC, ImageNet detection, and MS-COCO benchmarks for WSOD. Results show that our method outperforms the previous state of the art significantly.",
        "INTRODUCTION": "O BJECT detection is one of the most important problems in computer vision with many applications. Recently, due to the development of Convolutional Neural Network (CNN) [1],  #b13  and the availability of large scale datasets with detailed boundingbox-level annotations  #b14 ,  #b15 ,  #b16 , there have been great leap forwards in object detection  #b17 ,  #b18 ,  #b19 ,  #b20 ,  #b21 ,  #b22 . However, it is very labor-intensive and time-consuming to collect detailed annotations, whereas acquiring images with only image-level annotations (i.e., image tags) indicating whether an object class exists in an image or not is much easier. For example, we can use image search queries to search on the Internet (e.g., Google and Flickr) to obtain a mass of images with such image-level annotations. This fact inspires us to explore methods for the Weakly Supervised Object Detection (WSOD) problem, i.e., training object detectors with only image tag supervisions.Many previous methods follow the Multiple Instance Learning (MIL) pipeline for WSOD  #b23 ,  #b24 ,  #b25 ,  #b26 ,  #b27 ,  #b28 ,  #b29 ,  #b30 . They treat images as bags and proposals as instances; then instance classifiers (object detectors) are trained under MIL constraints (i.e., a positive bag contains at least one positive instance and all instances in negative bags are negative). In addition, inspired by the great success of CNN, recent efforts often combine MIL and CNN to obtain better WSOD performance. Some researches have shown that treating CNNs pre-trained on large scale datasets as offthe-shelf proposal feature extractors can obtain much better performance than traditional hand-designed features  #b23 ,  #b24 ,  #b25 ,  #b26 . Moreover, many recent works have achieved even better results for WSOD by an MIL network using standard end-to-end training  #b27 ,  #b29  or a variant of endto-end training  #b28 ,  #b30 . See Section 2.3 for this variant of end-to-end and how it differs from the standard one. We use the same strategy of training a variant of end-to-end MIL network inspired by  #b28 ,  #b30 .Although some promising results have been obtained by MIL networks for WSOD, they do not perform as well as fully supervised ones  #b17 ,  #b18 ,  #b19 . As shown in Fig. 3 (a), previous MIL networks integrate the MIL constraints into the network training by transferring the instance classification (object detection) problem to a bag classification (image classification) problem, where the final image scores are the aggregation of the proposal scores. However, there is a big gap between image classification and object detection. For classification, even parts of objects can contribute to correct results (e.g., the red boxes in Fig. 1), because important parts include many characteristics of the objects. Many proposals only cover parts of objects, and \"seeing\" proposals only of parts may be enough to roughly localize the objects. But this may not localize objects well enough considering the performance requirement of high Intersection-over-Union (IoU) between the resulting boxes and groundtruth bound-  ingboxes: the top ranking proposals may only localize parts of objects instead of whole objects. Recall that for detection, the resulting boxes should not only give correct classification, but also localize objects and have enough overlap with groundtruth boundingboxes (e.g., the green boxes in Fig. 1). Before presenting our solution of the problem referred above, we first introduce the concept of proposal cluster. Object detection requires algorithms to generate multiple overlapping proposals closely surrounding objects to ensure high proposal recall (e.g., for each object, there are tens of proposals on average from Selective Search  #b31  which have IoU>0.5 with the groundtruth boundingbox on the PASCAL VOC dataset). Object proposals in an image can be grouped into different spatial clusters. Except for one cluster for background proposals, each object cluster is associated with a single object and proposals in each cluster are spatially adjacent, as shown in Fig. 2. For fully supervised object detection (i.e., training object detectors using boundingboxlevel annotations), proposal clusters can be generated by treating the groundtruth boundingboxes as cluster centers. Then object detectors are trained according to the proposal clusters (e.g., assigning all proposals the label of the corresponding object class for each cluster). This alleviates the problem that detectors may only focus on parts.But in the weakly supervised scenario, it is difficult to generate proposal clusters because groundtruth boundingboxes that can be used as cluster centers are not provided. To cope with this difficulty, we suggest to find proposal clusters as follows. First we generate proposal cluster centers from those proposals which have high classification scores during training, because these top ranking proposals can always detect at least parts of objects. That is, for each image, after obtaining proposal scores, we select some proposals with high scores as cluster centers, and then proposal clusters are generated based on spatial overlaps with the cluster centers. Then the problem reduces to how to select proposals as centers, because many high scoring proposals may correspond to the same object. The most straightforward way is to  We propose to treat each proposal cluster as a small new bag. \"0\", \"1\", and \"2\" indicate the \"background\", \"motorbike\", and \"car\", respectively.{ \ud835\udc4b, 1, 2 } Object Detector (a) \ud835\udc4b { \ud835\udc65 1 , 0 , \ud835\udc65 2 , 0 \u2026 \ud835\udc65 4 , 1 , \ud835\udc65choose the proposal with the highest score for each positive object class (i.e., the object class exists in the image) as the center. But such a method ignores the fact that there may exist more than one object with the same object category in natural images (e.g., the two motorbikes in Fig. 2). Therefore, we propose a graph-based method to find cluster centers. More specifically, we build a graph of top ranking proposals according to the spatial similarity for each positive object class. In the graph, two proposals are connected if they have enough spatial overlaps. Then we greedily and iteratively choose the proposals which have most connections with others to estimate the centers. Although a cluster center proposal may only capture an object partially, its adjacent proposals (i.e., other proposals in the cluster) can cover the whole object, or at worst contain larger parts of the object.Based on these proposal clusters, we propose two methods to refine instance classifiers (object detectors) during training. We first propose to assign proposals object labels directly. That is, for each cluster, we assign its proposals the label of its corresponding object class, as in Fig. 3 (b). Compared with the conventional MIL network in Fig. 3 (a), this strategy forces network to \"see\" larger parts of objects by assigning object labels to proposals that cover larger parts of objects directly, which fills the gap between classification and detection to some extent. While effective, this strategy still has potential ambiguities, because assigning the same object label to proposals that cover different parts of objects simultaneously may confuse the network and will hurt the discriminative power of the detector. To address this problem, we propose to treat each proposal cluster as a small new bag to train refined instance classifiers, as in Fig. 3 (c). Most of the proposals in these new bags should have relatively high classification scores because the cluster centers covers at least parts of objects and proposals in the same cluster are spatially adjacent (except for the background cluster). In the same time, not all proposals in the bags should have high classification scores. Thus compared with the directly assigning label strategy, this strategy is more flexible and can reduce the ambiguities to some extent. We name our method Proposal Cluster Learning (PCL) because it learns refined instance classifiers based on proposal clusters.To implement our idea effectively and efficiently, we further propose an online training approach. Our network has multiple output streams as in Fig. 4. The first stream is a basic MIL network which aggregates proposal scores into final image scores to train basic instance classifiers, and the other streams refine the instance classifiers iteratively. During the forward process of training, proposal classification scores are obtained and proposal clusters are generated consequently for each stream. Then based on these proposal clusters, supervisions are generated to compute losses for the next stream. According to the losses, these refined classifiers are trained during back-propagation. Except for the first stream that is supervised by image labels, the other streams are supervised by the image labels as well as outputs from their preceding streams. As our method forces the network to \"see\" larger parts of objects, the detector can discover the whole object instead of parts gradually by performing refinement multiple times (i.e., multiple output streams). But at the start of training, all classifiers are almost untrained, which will result in very noisy proposal clusters, and so the training will deviate from the correct solutions a lot. Thus we design a weighted loss further by associating different proposals with different weights in different training iterations. After that, all training procedures can thus be integrated into a single end-to-end network. This can improve the performance benefiting from our PCL-based classifier refinement procedure. It is also very computational efficient in both training and testing. In addition, performance can be improved by sharing proposal features among different output streams.We elaborately conduct many experiments on the challenging PASCAL VOC, ImageNet detection, and MS-COCO datasets to confirm the effectiveness of our method. Our method achieves 48.8% mAP and 66.6% CorLoc on VOC 2007 which is more than 5% absolute improvement compared with previous best performed methods.This paper is an extended version of our previous work  #b32 . In particular, we give more analyses of our method and enrich literatures of most recent related works, making the manuscript more complete. In addition, we make two methodological improvements: the first one is to generate proposal clusters using graphs of top ranking proposals instead of using the highest scoring proposal, and the second one is to treat each proposal cluster as a small new bag. In addition, we provide more discussions of experimental results, and show the effectiveness of our method on the challenging ImageNet detection and MS-COCO datasets.The rest of our paper is organized as follows. In Section 2, some related works are introduced. In Section 3, the details of our method are described. Elaborate experiments and analyses are conducted in Section 4. Finally, conclusions and future directions are presented in Section 5.",
        "RELATED WORK": "",
        "Multiple instance learning": "MIL, first proposed for drug activity prediction  #b33 , is a classical weakly supervised learning problem. Many variants have been proposed for MIL  #b25 ,  #b34 ,  #b35 ,  #b36 . In MIL, a set of bags are given, and each bag is associated with a collection of instances. It is natural to treat WSOD as an MIL problem. Then the problem turns into finding instance classifiers only given bag labels. Our method also follows the MIL strategy and makes several improvements to WSOD. In particular, we learn refined instance classifiers based on proposal clusters according to both instance scores and spatial relations in an online manner. 1  MIL has many applications to computer vision, such as image classification  #b37 , [27], weakly supervised semantic segmentation  #b39 ,  #b40 , object detection  #b41 , object tracking  #b42 , etc. The strategy of treating proposal clusters as bags was partly inspired by  #b41 ,  #b42 , where  #b41  proposes to train MIL for patches around groundtruth locations and  #b42  proposes to train MIL for patches around predicted object locations. However, they require groundtruth locations for either all training samples  #b41  or the beginning time frames  #b42 , whereas WSOD does not have such annotations. Therefore, it is much harder to generate proposal clusters only guided by image-level supervisions for WSOD. In addition, we incorporate the strategy of treating proposal clusters as bags into the network training whereas  #b41 ,  #b42  do not. Oquab et al.  #b43  also train a CNN network using the max pooing MIL strategy to localize objects. But their methods can only coarsely localize objects regardless of their sizes and aspect ratios, whereas our method can detect objects more accurately.",
        "Weakly supervised object detection": "WSOD has attracted great interests nowadays because the amount of data with image-level annotations is much bigger and is growing much faster than that with boundingboxlevel annotations. Many methods are emerging for the WSOD problem  #b24 ,  #b25 ,  #b44 ,  #b45 ,  #b46 ,  #b47 ,  #b48 ,  #b49 ,  #b50 ,  #b51 . For example, Chum and Zisserman  #b44  first initialize object locations by discriminative visual words and then introduce an exemplar model to measure similarity between image pairs for updating locations. Deselaers et al.  #b45  propose to initialize boxes by objectness  #b52  and use a CRF-based model to iteratively localize objects. Pandey and Lazebnik  #b46  train a DPM model  #b53  under weak supervisions for WSOD. Shi et al.  #b47  use Bayesian latent topic models to jointly model different object classes and background. Song et al.  #b49  develop a technology to discover frequent discriminative configurations of visual patterns for robust WSOD. Cinbis et al.  #b24  iteratively train a multi-fold MIL to avoid the detector being locked onto inaccurate local optima. Wang et al.  #b25  relax the MIL constraints into a derivable loss function to train detectors more efficient.Recently, with the revolution of CNNs in computer vision, many works also try to combine the WSOD with CNNs. Early works treat CNN models pre-trained on Im-ageNet as off-the-shelf feature extractors  #b23 ,  #b24 ,  #b25 ,  #b26 ,  #b48 ,  #b49 ,  #b50 ,  #b51 . They extract CNN features for each candidate regions, and then train their own detectors on top of these features. These methods have shown that CNN descriptors can boost performance against traditional hand-designed features. More recent efforts tend to train end-to-end networks for WSOD  #b27 ,  #b28 ,  #b29 ,  #b30 . They integrate the MIL constraints into the network training by aggregating proposal classification scores into final image classification scores, and then image-level supervision can be directly added to image classification scores. For example, Tang et al.  #b27  propose to use max pooling for aggregation. Bilen and Vedaldi  #b28  develop a weighted sum pooing 1. \"Instance\" and \"proposal\" are used interchangeably in this paper.strategy. Building on  #b28 , Kantorov et al. argue that context information can improve the performance. Diba et al.  #b30  show that weakly supervised segmentation map can be used as guidance to filter proposals, and jointly train the weakly supervised segmentation network and WSOD end-to-end. Our method is built on these networks and any of them can be chosen as our basic network. Our strategy proposes to learn refined instance classifiers based on proposal clusters, and propose a novel online approach to train our network effectively and efficiently. Experimental results show our strategies can boost the results significantly.In addition to the weighted sum pooing,  #b28  also proposes a \"spatial regulariser\" that forces features of the highest scoring proposal and its spatially adjacent proposals to be the same. Unlike this, we show that finding proposal cluster centers using graph and treating proposal clusters as bags are more effective. The contemporary work  #b54  uses a graph model to generate seed proposals. Their network training has many steps: first, an MIL network  #b55  is trained; second, seed proposals are generated using the graph; third, based on these seed proposals, a Fast R-CNN  #b18  like detector is trained. Our method differs from  #b54  in many aspects: first, we propose to generate proposal clusters for each training iteration and thus our network is trained end-to-end instead of step-by-step, which is more efficient and can benefit from sharing proposal features among different streams; second, we propose to treat proposal clusters as bags for training better classifiers. As evidenced by experiments, our method obtains much better and more robust results.",
        "End-to-end and its variants": "In standard end-to-end training, the update requires optimizing losses w.r.t. all functions of network parameters. For example, the Fast R-CNN  #b18  optimizes their classification loss and boundingbox regression loss w.r.t. proposal classification and feature extraction for fully supervised object detection. The MIL networks in  #b27 ,  #b29  optimize their MIL loss w.r.t. proposal classification and feature extraction for WSOD.Unlike the standard end-to-end training, there exists a variant of end-to-end training. The variant contains functions which depend on network parameters, but losses are not optimized w.r.t. all these functions  #b28 ,  #b30 . As we described in Section 2.2, the \"spatial regulariser\" in  #b28  forces features of the highest scoring proposal and its spatially adjacent proposals to be the same. They use a function of network parameters to compute the highest scoring proposal, and do not optimize their losses w.r.t. this function. Diba et al.  #b30  filter out background proposals using a function of network parameters and use these filtered proposals in their latter network computations. They also do not optimize their losses w.r.t. this function. Inspired by  #b28 ,  #b30 , we use this variant of end-to-end training. More precisely, we do not optimize our losses w.r.t. the generated supervisions for instance classifier refinement.",
        "Others": "There are many other important related works that do not focus on weakly supervised learning but should be discussed. Similar to other end-to-end MIL networks, our method is built on top of the Region of Interest (RoI) pooling layer  #b18  or Spatial Pyramid Pooling (SPP) layer  #b56  to share convolutional computations among different proposals for model acceleration. But both  #b18  and  #b56  require boundingbox-level annotations to train their detectors. The sharing proposal feature strategy in our network is similar to multi-task learning  #b57 . Unlike the multi-task learning that each output stream has their own relatively independent external supervisions for different tasks, in our method, all streams have the same task and supervisions of later streams depend on the outputs from their preceding streams.",
        "METHOD": "The overall architecture of our method is shown in Fig. 4. Given an image, about 2, 000 object proposals from Selective Search  #b31  or EdgeBox  #b58  are generated. During the forward process of training, the image and these proposals are fed into some convolutional (conv) layers with an SPP layer  #b56  to produce a fixed-size conv feature map per-proposal. After that, proposal feature maps are fed into two fully connected (fc) layers to produce proposal features. These features are branched into different streams: the first one is an MIL network to train basic instance classifiers and the others refine the classifiers iteratively. For each stream, proposal classification scores are obtained and proposal clusters are generated consequently. Then based on these proposal clusters, supervisions are generated to compute losses for the next stream. During the back-propagation process of training, the network losses are optimized to train proposal features and classifiers. As shown in the figure, supervisions of the 1-st refined classifier depend on the output from the basic classifier, and supervisions of k-th refined classifier depend on outputs from {k -1}-th refined classifier. In this section, we will introduce our method of learning refined instance classifiers based on proposal clusters in detail.",
        "Notations": "Before presenting our method, we first introduce some of the mostly used notations as follows. We have R proposals with boxes B = {b r } R r=1 for an given image and proposal features F, where b r is the r-th proposal box. The number of refined instance classifiers is K (i.e., we refine instance classifier K times), and thus there are K + 1 streams. The number of object classes is C. W 0 and W k , k \u2208 {1, ..., K} are the parameters of the basic instance classifier and the k-th refined instance classifier, respectively. \u03d5 0 (F, W 0 ) \u2208 R C\u00d7R and \u03d5 k (F, W k ) \u2208 R (C+1)\u00d7R , k \u2208 {1, ..., K} are the predicted score matrices of the basic instance classifier and the k-th refined instance classifier, respectively, where C + 1 indicates the C object classes and 1 background class. We use \u03d5 k later for simplification, dropping the dependence on F, W k . \u03d5 k cr is the predicted score of the r-th proposal for class c from the k-th instance classifier. y = [y 1 , ..., y C ] T is the image label vector, where y c = 1 or 0 indicates the image with or without object class c. H k (\u03d5 k-1 , y) is the supervision of the k-th instance classifier, whereH k (\u03d5 k-1 , y), k = 0 is the image label vector y. L k F, W k , H k (\u03d5 k-1 , y) is the loss function to train the k-th instance classifier. We compute N k proposal cluster centers S k = {S k n } N k n=1for the k-th refinement. The n-th cluster center S k n = (b k n , y k n , s k n ) consists of a proposal box b k n \u2208 B,k n . We have N k + 1 proposal clusters C k = {C k n } N k +1 n=1 according to S k (C k N k +1for background and others for objects). For object clusters, the n-th clusterC k n = (B k n , y k n , s k n ), n = N k + 1 consists of M k n proposal boxes B k n = {b k nm } M k n m=1 \u2286 B, an object label y k nthat is the same as the cluster center label, and a confidence score s k n that is the same as the cluster center score, where s k n indicates the confidence that C k n corresponds to an object of class y k n . Unlike object clusters, the background cluster C k n = (P k n , y k n ), n = N k + 1 consists of M k n proposals P k n = {P k nm } M k n m=1",
        "Basic MIL network": "It is necessary to generate proposal scores and clusters to supervise refined instance classifiers. More specifically, the first refined classifier requires basic instance classifiers to generate proposal scores and clusters. Therefore, we first introduce our basic MIL network as the basic instance classifier. Our overall network is independent of the specific MIL methods, and thus any method that can be trained endto-end could be used. There are many possible choices  #b27 ,  #b28 ,  #b29 . Here we choose the method by Bilen and Vedaldi  #b28  which proposes a weighted sum pooling strategy to obtain the instance classifier, because of its effectiveness and implementation convenience. To make our paper selfcontained, we briefly introduce  #b28  as follows.Given an input image and its proposal boxes B = {b r } R r=1 , a set of proposal features F are first generated by the network. Then as shown in the \"Basic MIL network\" block of Fig. 4, there are two branches which process the proposal features to produce two matrices X cls (F, W cls ), X det (F, W det ) \u2208 R C\u00d7R (we use X cls , X det later for simplification, dropping the dependence on F, W cls , W det ) of an input image by two fc layers, where W cls and W det denote the parameters of the fc layer for X cls and the parameters of the fc layer for X det , respectively. Then the two matrices are passed through two softmax layer along different directions: [\u03c3(X cls )] cr = e x cls cr / C c =1 e x cls c r and [\u03c3(X det )] cr = e x det cr / R r =1 e x det cr . Let us denote (W cls , W det ) by W 0 . The proposal scores are generated by element-wise product \u03d5 0 (F, W 0 ) = \u03c3(X cls ) \u03c3(X det ). Finally, the image score of the c-th class [\u03c6(F, W 0 )] c is obtained by the sum over all proposals:[\u03c6(F, W 0 )] c = R r=1 [\u03d5 0 (F, W 0 )] cr .A simple interpretation of the two branches framework is as follows. [\u03c3(X cls )] cr is the probability of the r-th proposal belonging to class c. [\u03c3(X det )] cr is the normalized weight that indicates the contribution of the r-th proposal to image being classified to class i. So [\u03c6(F, W 0 )] c is obtained by weighted sum pooling and falls in the range of (0, 1). Given the image label vector y = [y 1 , ..., y C ] T . We train the Algorithm 1 The overall training procedure (one iteration) Input: An image, its proposal boxes B, and its image label vector y = [y 1 , ..., y C ] T ; refinement times K. Output: An updated network. 1: Feed the image and B into the network to produce proposal score matrices \u03d5 k (F, W k ), k \u2208 {0, 1, ..., K} (simplified as \u03d5 k later). 2: Compute loss L 0 F, W 0 , y by Eq. (1), see Section 3.2. 3: for k = 1 to K do 4:Generate supervisions H k (\u03d5 k-1 , y), see Section 3.4.",
        "5:": "Build a graph G k c using the top ranking proposals. until V k c is empty.proposals) as in Eq. ( 4), where I rr is the IoU between the r-th and r -th proposals and I t is a threshold (e.g., 0.4).e rr = 1 if I rr > I t , 0 otherwise.(4)Therefore, two vertexes are connected if they are spatially adjacent. After that, we greedily generate some cluster centers for class c using this graph. That is, we iteratively select vertexes which have most connections to be the cluster centers, as in Algorithm 3. The number of cluster centers (i.e., N k ) changes for each image in each training iteration because the top ranking proposals R k c change. See Section 4.2.9 for some typical values of N k . We use the same method as in Section 3.4.1 (1) to avoid one proposal been chosen as the cluster centers for multiple object classes.The reasons for this strategy are as follows. First, according to our observation, the top ranking proposals can always cover at least parts of objects, thus generating centers from these proposals encourages the selected centers to meet our requirements. Second, because these proposals cover objects well, better proposals (covering more parts of objects) should have more spatially overlapped proposals (i.e., have more connections). Third, these centers are spatially far apart, and thus different centers can correspond to different objects. This method also has the attractive characteristic that it can generate adaptive number of proposals for each object class, which is desirable because in natural images there are arbitrary number of objects per-class. We set the score of the n-th proposal cluster center s k n by s k n = max There is an important issue for the graph-based method: how to select the top ranking proposals? A simple method is to select proposals whose scores exceed a threshold. But in our case, proposal scores change in each training iteration, and thus it is hard to determine a threshold. Instead, for each Algorithm 4 Generating proposal clustersInput: Proposal boxes B = {b 1 , ..., b R }; proposal cluster centers S k = {S k 1 , ..., S k N k }. Output: Proposal clusters C k . 1: Initialize B k n = \u2205, \u2200n = N k + 1. 2: Set y k n , s k n of C k n to y k n , s k n of S k n , \u2200n = N k + 1. 3: Initialize P k N k +1 = \u2205 and set y k N k +1 = C + 1. 4: for r = 1 to R do 5:Compute IoUs {I k r1 , ..., I k rN k }.  P k N k +1 .append (b r , s k n k r ) .positive object class, we use the k-means  #b59  algorithm to divide proposal scores of an image into some clusters, and choose proposals in the cluster which has the highest score center to form the top ranking proposals. This method ensures that we can select the top ranking proposals although proposal scores change during training. Other choices are possible, but this method works well in experiments.",
        "6: Optimize": "K k=0 L k F, W k , H k (\u03d5 k-1 , y) , i.e., Eq. (2), w.r.t. F, W k (not w.r.t. H k (\u03d5 k-1 , y)).basic instance classifier by optimizing the multi-class cross entropy loss Eq. (1) w.r.t. F, W 0 .L 0 F, W 0 , y = - C c=1 {(1 -y c ) log(1 -[\u03c6(F, W 0 )] c ) +y c log[\u03c6(F, W 0 )] c }.(1)",
        "The overall training strategy": "To refine instance classifiers iteratively, we add multiple output streams in our network where each stream corresponds to a refined classifier, as shown in Fig. 4. We integrate the basic MIL network and the classifier refinement into an end-to-end network to learn the refined classifier online. Unlike the basic instance classifier, for an input image the output score matrix \u03d5 k (F, W k ) of the k-th refined classifier is a {C + 1} \u00d7 R matrix and is obtained by passing the proposal features through a single fc layer (with parameters W k ) as well as a softmax over-classes layer, i.e., \u03d5 k (F, W k ) \u2208 R (C+1)\u00d7R , k \u2208 {1, 2, ..., K}, as in the \"Instance classifier refinement\" blocks of Fig. 4. Notice that we use the same proposal features F for all classifiers. We use \u03d5 k later for simplification, dropping the dependence on F, W k .As we stated before, supervisions to train the k-th instance classifier are generated based on proposal scores \u03d5 k-1 and image label y. Thus we denote the supervisions by H k (\u03d5 k-1 , y). Then we train our overall network by optimizing the loss Eq. ( 2) w.r.t. F, W k . We do not optimize the loss w.r.t. H k (\u03d5 k-1 , y), which means that the supervisions H k (\u03d5 k-1 , y) are only computed in the forward process and we do not compute their gradients to train our network.K k=0 L k F, W k , H k (\u03d5 k-1 , y) .(2)The loss L k F, W k , H k (\u03d5 k-1 , y) , k > 0 for the k-th refined instance classifier is defined in later Eq. ( 6)/(7)/(8) which are loss functions with supervisions provided by H k (\u03d5 k-1 , y). We will give details about how to get supervisions H k (\u03d5 k-1 , y) and loss functionsL k F, W k , H k (\u03d5 k-1 , y) in Section 3.4.During the forward process of each Stochastic Gradient Descent (SGD) training iteration, we obtain a set of proposal scores of an input image. Accordingly, we generate the supervisions H k (\u03d5 k-1 , y) for the iteration to compute the loss Eq. ( 2). During the back-propagation process of each SGD training iteration, we optimize the loss Eq. ( 2) w.r.t. proposal features F and classifiers W k . We summarize this procedure in Algorithm 1. Note that we do not use an alternating training strategy, i.e., fixing supervisions and training a complete model, fixing the model and updating supervisions. The reasons are that: 1) it is very time-consuming because it requires training models multiple times; 2) training different models in different refinement steps separately may harm the performance because it hinders the process to benefit from the shared proposal features (i.e., F).",
        "Proposal cluster learning": "Here we will introduce our methods to learn refined instance classifiers based on proposal clusters (i.e., proposal cluster learning).Recall from Section 3.1 that we have a set of proposals with boxes B = {b r } R r=1 . For the k-th refinement, our goal is to generate supervisions H k (\u03d5 k-1 , y) for the loss functions L k F, W k , H k (\u03d5 k-1 , y) using the proposal scores \u03d5 k-1 and image label y in each training iteration. We use H k , L k later for simplification, dropping the dependence on \u03d5 k-1 , y, F, W k .We do this in three steps. 1) We find proposal cluster centers which are proposals corresponding to different objects. 2) We group the remaining proposals into different clusters, where each cluster is associated with a cluster center or corresponds to the background. 3) We generate the supervisions H k for the loss functions L k , enabling us to train the refined instance classifiers.For the first step, we compute proposal cluster centers S k = {S k n } N k n=1 based on \u03d5 k-1 and y. The n-th cluster centerS k n = (b k n , y k n , s k n )is defined in Section 3.1. We propose two algorithms to find S k in Section 3.4.1 (1) and (2) (also Algorithm 2 and Algorithm 3), where the first one was proposed in the conference version paper  #b32  and the second one is proposed in this paper.For the second step, according to the proposal cluster centers S k , proposal clustersC k = {C k n } N k +1 n=1 are generated (C k N k +1for background and others for objects). The n-thobject cluster C k n = (B k n , y k n , s k n ), n = N k + 1 and the background cluster C k n = (P k n , y k n ), n = N k +1are defined in Section 3.1. We use the different notation for the background cluster because background proposals are scattered in each image, and thus it is hard to determine a cluster center and accordingly a cluster score. The method to generate C k was proposed in the conference version paper and is described in Section 3.4.2 (also Algorithm 4).For the third step, supervisions H k to train the k-th refined instance classifier are generated based on the proposal clusters. We use two strategies where H k are either proposal-level labels indicating whether a proposal belongs to an object class, or cluster-level labels that treats each proposal cluster as a bag. Subsequently these are used to compute the loss functions L k . We propose two approaches to do this as described in Section 3.4.3 (1) and  #b13 , where the first one was proposed in the conference version paper and the second one is proposed in this paper. Choose the r k c -th proposal by Eq. (3).5:S k .append (b r k c , c, \u03d5 k-1 cr k c) .",
        "Finding proposal cluster centers": "In the following we introduce two algorithms to find proposal cluster centers.(1) Finding proposal cluster centers using the highest scoring proposal. A solution for finding proposal cluster centers is to choose the highest scoring proposal, as in our conference version paper  #b32 . As in Algorithm 2, suppose an image has object class label c (i.e., y c = 1). For the k-th refinement, we first select the r k c -th proposal which has the highest score by Eq. ( 3), where \u03d5 k-1 cr is the predicted score of the r-th proposal, as defined in Section 3.1.r k c = argmax r \u03d5 k-1 cr .(3)Then this proposal is chosen as the cluster center, i.e.,S k n = (b k n , y k n , s k n ) = (b r k c , c, \u03d5 k-1 cr k c), where b r k c is the box of the r k c -th proposal. \u03d5 k-1 cr is chosen as the confidence score that the r-th proposal covers at least part of an object of class c, because \u03d5 k-1 cr is the predicted score of the r-th proposal been categorized to class c. Therefore, the highest scoring proposal can probably cover at least part of the object and thus be chosen as the cluster center.There is a potential problem that one proposal may be chosen as the cluster centers for multiple object classes. To avoid this problem, if one proposal corresponds to the cluster centers for multiple object classes, this proposal would be chosen as the cluster center only by the class with the highest predicted score and we re-choose cluster centers for other classes.(2) Finding proposal cluster centers using graphs of top ranking proposals. As stated in Section 1, although we can find good proposal cluster centers using the highest scoring proposal, this ignores that in natural images there are often more than one object for each category. Therefore, we propose a new method to find cluster centers using graphs of top ranking proposals.More specifically, suppose an image has object class label c. We first select the top ranking proposals with indexesR k c = {r k c1 , ..., r k cN k c} for the k-th refinement. Then we build an undirected unweighted graph G k c = (V k c , E k c ) of these proposals based on spatial similarity, where vertexes V k c correspond to these top ranking proposals, and edges Select top ranking proposals with indexes R k c .E k c = {e k crr } = {e(v k cr , v k cr )}, r, r \u2208 R k c correspond",
        "Generating proposal clusters": "After the cluster centers are found, we generate the proposal clusters as in our conference version paper  #b32 . Except for the cluster for background, good proposal clusters require that proposals in the same cluster are associated with the same object, and thus proposals in the same cluster should be spatially adjacent. Specially, given the r-th proposal, we compute a set of IoUs {I k r1 , ..., I k rN k where I k rn is the IoU between the r-th proposal and the box b k n of the n-th cluster center. Then we assign the r-th proposal to the n k r -th object cluster if I k rn k r is larger than a threshold I t (e.g., 0.5) and to the background cluster otherwise, where n k r is the index of the most spatially adjacent cluster center as Eq.  #b16 .n k r = argmax n I k rn .(5)The overall procedures to generate proposal clusters are summarized in Algorithm 4. We set the proposal scores for the background cluster to the scores of their most spatially adjacent centers as the 10-the line in Algorithm 4, because if the cluster center S k n has confidence s k n that it covers an object, the proposal far away from S k n should have confidence s k n to be background.",
        "Learning refined instance classifiers": "To get supervisions H k and loss functions L k to learn the k-th refined instance classifier, we design two approaches as follows.(1) Assigning proposals object labels. The most straightforward way to refine classifiers is to directly assign object labels to all proposals in object clusters because these proposals potentially correspond to whole objects, as in our conference version paper  #b32 . As the cluster centers covers at least parts of objects, their adjacent proposals (i.e., proposals in the cluster) can contain larger parts of objects. Accordingly, we can assign the cluster label y k n to all proposals in the n-th cluster.More specifically, the supervisions H k are proposal-level labels, i.e., H k = {y k r } R r=1 . y k r = [y k 1r , ..., y k (C+1)r ] T \u2208 R (C+1)\u00d71 is the label vector of the r-th proposal for the kth refinement, where y k y k n r = 1 and y k cr = 0, c = y k n if the r-th proposal belongs to the n-th clusters. Consequently, we use the standard softmax loss function to train the refined classifiers as in Eq. ( 6), where \u03d5 k cr is the predicted score of the r-th proposal as defined in Section 3.1.L k F, W k , H k = - 1 R R r=1 C+1 c=1 y k cr log \u03d5 k cr .(6)Through iterative instance classifier refinement (i.e., multiple times of refinement as k increase), the detector detects larger parts of objects gradually by forcing the network to \"see\" larger parts of objects.Actually, the so learnt supervisions H k are very noisy, especially in the beginning of training. This results in unstable solutions. To solve this problem, we change the loss in Eq. ( 6) to a weighted version, as in Eq. ( 7).L k F, W k , H k = - 1 R R r=1 C+1 c=1 \u03bb k r y k cr log \u03d5 k cr .(7)\u03bb k r is the loss weight that is the same as the cluster confidence score s k n for object clusters or proposal confidence score s k nm for the background cluster if the r-th proposal belongs to the n-th cluster. From Algorithm 4, we can observe that \u03bb k r is the same as the cluster center confidence score s k n . The reasons for this strategy are as follows. In the beginning of training, although we cannot obtain good proposal clusters, each s k n is small, hence each \u03bb k r is small and the loss is also small. As a consequence, the performance of the network will not decrease a lot. During the training, the top ranking proposals will cover objects well, and thus we can generate good proposal clusters. Then we can train satisfactory instance classifiers.(2) Treating clusters as bags. As we stressed before, although directly assigning proposals object labels can boost the results, it may confuse the network because we simultaneously assign the same label to different parts of objects. Focusing on this, we further propose to treat each proposal cluster as a small new bag and use the cluster label as the bag label. Thus the supervisions H k for the k-th refinement are bag-level (cluster-level) labels, i.e.,H k = {y k n } N k +1 n=1 . y k nis the label of the n-th bag, i.e., the label of the n-th proposal cluster, as defined in Section 3.1.Specially, for object clusters, we choose average MIL pooling, because these proposals should cover at least parts of objects and thus should have relatively high prediction scores. For the background cluster, we assign the background label to all proposals in the cluster according to the MIL constraints (all instances in negative bags are negative).Then the loss function for refinement will be Eq. ( 8).L k F, W k , H k = - 1 R ( N k n=1 s k n M k n log r s.t. br\u2208B k n \u03d5 k y k n r M k n + r\u2208C k N k +1 \u03bb k r log \u03d5 k (C+1)r ). (8) s k n , M kn , and \u03d5 k cr are the cluster confidence score of the n-th object cluster, the number of proposals in the n-th cluster, and the predicted score of the r-th proposal, respectively, as defined in Section 3.1. b r \u2208 B k n and r \u2208 C k N k +1 indicate that the r-th proposal belongs to the n-th object cluster and the background cluster respectively.Compared with the directly assigning label approach, this method tolerates some proposals to have low scores, which can reduce the ambiguities to some extent.",
        "Testing": "During testing, the proposal scores of refined instance classifiers are used as the final detection scores, as the blue arrows in Fig. 4. Here the mean output of all refined classifiers is chosen. The Non-Maxima Suppression (NMS) is used to filter out redundant detections.",
        "EXPERIMENTS": "In this section, we first introduce our experimental setup including datasets, evaluation metrics, and implementation details. Then we conduct elaborate experiments to discuss the influence of different settings. Next, we compare our results with others to show the effectiveness of our method. After that, we show some qualitative results for further analyses. Finally, we give some runtime analyses of our method. Codes for reproducing our results are available at https://github.com/ppengtang/oicr/tree/pcl.",
        "Experimental setup": "",
        "Datasets and evaluation metrics": "We evaluate our method on four challenging datasets: the PASCAL VOC 2007 and 2012 datasets  #b14 , the ImageNet detection dataset  #b15 , and the MS-COCO dataset  #b16 . Only image-level annotations are used to train our models.The PASCAL VOC 2007 and 2012 datasets have 9, 962 and 22, 531 images respectively for 20 object classes. These two datasets are divided into train, val, and test sets. Here we choose the trainval set (5, 011 images for 2007 and 11, 540 images for 2012) to train our network. For testing, there are two metrics for evaluation: mAP and CorLoc. Following the standard PASCAL VOC protocol  #b14 , Average Precision (AP) and the mean of AP (mAP) is the evaluation metric to test our model on the testing set. Correct Localization (CorLoc) is to test our model on the training set measuring the localization accuracy  #b45 . All these two metrics are based on the PASCAL criterion, i.e., IoU>0.5 between groundtruth boundingboxes and predicted boxes.The ImageNet detection dataset has hundreds of thousands of images with 200 object classes. It is also divided into train, val, and test sets. Following  #b17 , we split the val set into val1 and val2, and randomly choose at most 1K images in the train set for each object class (we call it train 1K ). We train our model on the mixture of train 1K and val1 sets, and test it on the val2 set, which will lead to 160, 651 images for training and 9, 916 images for testing. We also use the mAP for evaluation on the ImageNet.The MS-COCO dataset has 80 object classes and is divided into train, val, and test sets. Since the groundtruths on the test set are not released, we train our model on the MS-COCO 2014 train set (about 80K images) and test it on the val set (about 40K images). For evaluation, we use two metrics mAP@0.5 and mAP@[.5, .95] which are the standard PASCAL criterion (i.e., IoU>0.5) and the standard MS-COCO criterion (i.e., computing the average of mAP for IoU\u2208[0.5 : 0.05 : 0.95]) respectively.",
        "Implementation details": "Our method is built on two pre-trained ImageNet  #b15  networks VGG M  #b60  and VGG16  #b61 , each of which has some conv layers with max-pooling layers and three fc layers. We replace the last max-pooling layer by the SPP layer, and the last fc layer as well as the softmax loss layer by the layers described in Section 3. To increase the feature map size from the last conv layer, we replace the penultimate max-pooling layer and its subsequent conv layers by the dilated conv layers  #b62 ,  #b63 . The newly added layers are initialized using Gaussian distributions with 0-mean and standard deviations 0.01. Biases are initialized to 0.During training, the mini-batch size for SGD is set to be 2, 32, and 4 for PASCAL VOC, ImageNet, and MS-COCO, respectively. The learning rate is set to 0.001 for the first 40K, 60K, 15K, and 85K iterations for the PASCAL VOC 2007, PASCAL VOC 2012, ImageNet, and MS-COCO datasets, respectively. Then we decrease the learning rate to 0.0001 in the following 10K, 20K, 5K, and 20K iterations for the PASCAL VOC 2007, PASCAL VOC 2012, ImageNet, and MS-COCO datasets, respectively. The momentum and weight decay are set to be 0.9 and 0.0005 respectively.Selective Search  #b31 , EdgeBox  #b58 , and MCG  #b64  are adopted to generate about 2, 000 proposals per-image for the PASCAL VOC, ImageNet, and MS-COCO datasets, respectively. For data augmentation, we use five image scales {480, 576, 688, 864, 1200} (resize the shortest side to one of these scales) with horizontal flips for both training and testing. If not specified, the instance classifiers are refined three times, i.e., K = 3 in Section 3.3, so there are four output streams; the IoU threshold I t in Section 3.4.1 (2) (also Eq. ( 4)) is set to 0.4; the number of k-means clusters in the last paragraph of Section 3.4.1 (2) is set to 3; I t in Section 3.4.2 (also the 5-th line of Algorithm 4) is set to 0.5.Similar to other works  #b30 ,  #b54 ,  #b65 , we train a supervised object detector through choosing the top-scoring proposals given by our method as pseudo groundtruths to further improve our results. Here we train a Fast R-CNN (FRCNN)  #b18  using the VGG16 model and the same five image scales (horizontal flips only in training). The same proposals are chosen to train and test the FRCNN. NMS (with 30% IoU threshold) is applied to compute AP.Our experiments are implemented based on the Caffe [55] deep learning framework, using Python and C++. The k-means algorithm to produce top ranking proposals is ",
        "Discussions": "We first conduct some experiments to discuss the influence of different components of our method (including instance classifier refinement, different proposal generation methods, different refinement strategies, and weighted loss) and different parameter settings (including the IoU threshold I t defined in Section 3.4.1 (2), the number of k-means clusters described in Section 3.4.1 (2), the IoU threshold I t defined in Section 3.4.2, and multi-scale training and testing.) We also discuss the number of proposal cluster centers. Without loss of generality, we only perform experiments on the VOC 2007 dataset and use the VGG M model.",
        "The influence of instance classifier refinement": "As the five curves in Fig. 5 show, we observe that compared with the basic MIL network, for both refinement methods, even refining instance classifier a single time boosts the performance a lot. This confirms the necessity of refinement.If we refine the classifier multiple times, the results are improved further. But when refinement is implemented too many times, the performance gets saturated (there are no obvious improvements from 3 times to 4 times). This is because the network tends to converge so that the supervision of the 4-th time is similar to the 3-rd time. In the rest of this paper we only refine classifiers 3 times. Notice that in Fig. 5, the \"0 time\" is similar to the WSDDN  #b28  using Selective Search as proposals.",
        "The influence of different proposal cluster generation methods": "We discuss the influence of different proposal cluster generation methods. As shown in the Fig. 5 (green and purple solid curves for the highest scoring proposal based method, blue and red solid curves for the graph-based method), for all refinement times, the graph-based method obtains better performance, because it can generate better cluster centers.Thus we choose the graph-based method in the rest of our paper.  ",
        "The influence of different refinement strategies": "We then show the influence of different refinement strategies. The directly assigning label method is replaced by treating clusters as bags (blue and green solid curves). From In the rest of our paper, we only report results by the \"PCL-OB-G\" method in Fig. 5 because it achieves the best performance.",
        "The influence of weighted loss": "We also study the influence of our weighted loss in Eq.  #b19 . Note that Eq. ( 8) can be easily changed to the unweighted version by simply setting \u03bb k r and s k n to be 1. Here we train a network using the unweighted loss. The results of the unweighted loss are mAP 33.6% and CorLoc 51.2%. We see that if we use the unweighted loss, the improvement from refinement is very scant and the performance is even worse than the alternating strategy. Using the weighted loss achieves much better performance (mAP 40.8% and CorLoc 59.6%), which confirms our theory in Section 3.4.3.",
        "The influence of the IoU threshold I t": "Here we discuss the influence of the IoU threshold I t defined in Section 3.4.1 (2) and Eq. ( 4). From Fig. 6, we see that setting I t to 0.4 obtains the best performance. Therefore, we set I t to 0.4 for the other experiments.",
        "The influence of the number of k-means clusters": "In previous experiments we set the number of k-means clusters described in the last paragraph of Section 3.4.1 (2) to be 3. Here we set it to other numbers to explore its influence. The results from other numbers of k-means clusters are mAP 40.2% and CorLoc 59.3% for 2 clusters, and mAP 40.7% and CorLoc 59.6% for 4 clusters, which are a little worse than the results from 3 cluster. Therefore, we set the number of k-means clusters to 3 for the other experiments. We also analyse the influence of I t defined in Section 3.4.2 and the 5-th line of Algorithm 4. As shown in Fig. 7, I t = 0.5 outperforms other choices. Therefore, we set I t to 0.5 for the other experiments.",
        "The influence of multi-scale training and testing": "Previously our experiments are conducted based on five image scales for training and testing. Here we show the influence of this multi-scale setting. We train and test our method using a single image scale 600 as the default scale setting of FRCNN  #b18 . The single-scale results are mAP 37.4% and CorLoc 55.5% which are much worse than our multi-scale results (mAP 40.8% and CorLoc 59.6%). Therefore, we use five image scales as many WSOD networks  #b28 ,  #b29 ,  #b30 .",
        "The number of proposal cluster centers": "As we stated in Section 3.  proposal cluster centers for each image. After some (about 3K) training iterations, the proposal scores are more reliable and our method finds 1\u223c3 proposal cluster centers for each positive object class. To make the training more stable in the beginning, for each positive object class we empirically select at most five proposal cluster centers which have higher scores, and the number of selected proposal cluster centers does not influence the performance much.",
        "Comparison with other methods": "Here we compare our best performed strategy PCL-OB-G, i.e., using graph-based method and treating clusters as bags to train the network online, with other methods. We first report our results for each class on VOC 2007 and 2012 in Table 1, Table 2, Table 3, and Table 4. It is obvious that our method outperforms other methods  #b28 ,  #b29  using single model VGG M or VGG16 (PCL-OB-G+VGG M and PCL-OB-G+VGG16 in tables.) Our single model results even better than others by combining multiple different models (e.g., ensemble of models)  #b28 ,  #b30 ,  #b54 ,  #b65 . Specially, our method obtains much better results compared with other two methods also using the same basic MIL network  #b28 ,  #b29 . Importantly,  #b28  also equips the weighted sum pooling with objectness measure of EdgeBox  #b58  and the spatial regulariser, and  #b29  adds context information into the network, both of which are more complicated than our basic MIL network. We believe that our performance can be improved by choosing better basic MIL networks, like the complete network in  #b28  and using context information  #b29 . As reimplementing their method completely is nontrivial, here we only choose the simplest architecture in  #b28 . Even in this simplified case, our method achieves very promising results.Our results can also be improved by combing multiple models. As shown in the tables, there are little improvements from the ensemble of the VGG M and VGG16 models (PCL-OB-G-Ens. in tables). Here we do the ensemble by summing up the scores produced by the two models. Also, as mentioned in Section 4.1, similar to  #b30 ,  #b54 ,  #b65 , we train a FRCNN detector using top-scoring proposals produced by PCL-OB-G-Ens. as groundtruths (PCL-OB-G-Ens.+FRCNN in tables). As we can see, the performance is improved further.We then show results of our method on the large scale ImageNet detection dataset in Table 5. We observe similar phenomenon that our method outperforms other methods by a large margin.  We finally report results of our method on MS-COCO in Table 6. Our method obtains better performance than the recent work  #b2 . In particular, Ge et al.  #b2  use the method proposed in our conference version paper  #b32  as a basic component. We can expect to obtain better detection performance through replacing our conference version method in  #b2  by our newly proposed method here, which we would like to explore in the future.",
        "Qualitative results": "We first show some proposal clusters generated by our method in Fig. 8. As we can see, the cluster centers contain at least parts of objects and are able to cover adaptive number of objects for each class.We then show qualitative comparisons among the WS-DDN  #b28 , the WSDDN+context  #b29 , and our PCL method, both of which use the same basic MIL network. As shown in Fig. 9, we can observe that for classes such as bike, car, cat, etc., our method tends to provide more accurate detections, whereas other two methods sometimes fails by producing boxes that are overlarge or only contain parts of objects (the first four rows in Fig. 9). But for some classes such as person, our method sometimes fails by only detecting parts of objects such as the head of person (the fifth row in Fig. 9). Exploiting context information sometimes help the detection (as in WSDDN+context  #b29 ), we believe our method can be further improved by incorporating context information into our framework. All these three methods (actually almost all weakly supervised object detection methods) suffers from two problems: producing boxes that not only contain the target object but also include their adjacent similar objects, or only detecting parts of object for objects with deformation (the last row in Fig. 9). We finally visualize some success and failure detection results on VOC 2007 trainval by PCL-Ens.+FRCNN, as in Fig. 10. We observe similar phenomena as in Fig. 9. Our method is robust to the size and aspect of objects, especially for rigid objects. The main failures for these rigid objects are always due to overlarge boxes that not only contain objects, but also include adjacent similar objects. For nonrigid objects like \"cat\", \"dog\", and \"person\", they often have great deformations, but their parts (e.g., head of person) have much less deformation, so our detector is still inclined to find these parts. An ideal solution is yet wanted because there is still room for improvement.",
        "Runtime": "The runtime comparisons between our method and our basic MIL network  #b28  are shown in Table 7, where the runtime of proposal generation is not considered. As we can see, although our method has more components than our basic MIL network  #b28 , our method takes almost the same testing time as it. This is because all our output ",
        "CONCLUSION": "In this paper, we propose to generate proposal clusters to learn refined instance classifiers for weakly supervised object detection. We propose two strategies for proposal cluster generation and classifier refinement, both of which can boost the performance significantly. The classifier refinement is implemented by multiple output streams corresponding to some instance classifiers in multiple instance learning networks. An online training algorithm is introduced to train the proposed network end-to-end for effectiveness and efficiency. Experiments show substantial and consistent improvements by our method. We observe that the most common failure cases of our algorithm are connected with the deformation of non-rigid objects. In the future, we will concentrate on this problem. In addition, we believe our learning algorithm has the potential to be applied in other weakly supervised visual learning tasks such as weakly supervised semantic segmentation. We will also explore how to apply our method to these related applications."
    },
    {},
    {
        "b0": [
            "",
            "",
            "",
            ""
        ],
        "b1": [
            "",
            "",
            "",
            ""
        ],
        "b2": [
            "",
            "",
            "CorLoc in %) for different methods on the VOC 2007 trainval set. The upper part shows the results using a single model. The lower part shows the results of combing multiple models",
            ""
        ],
        "b3": [
            "",
            "",
            "",
            ""
        ],
        "b4": [
            "",
            "",
            "",
            ""
        ],
        "b5": [
            "",
            "",
            "",
            ""
        ],
        "b6": [
            "",
            "",
            "",
            ""
        ],
        "b7": [
            "",
            "",
            "",
            ""
        ],
        "b8": [
            "",
            "",
            "CorLoc in %) for different methods on the VOC 2012 trainval set",
            ""
        ],
        "b9": [
            "",
            "",
            "",
            ""
        ],
        "b10": [
            "",
            "",
            "",
            ""
        ],
        "b11": [
            "",
            "",
            "",
            ""
        ],
        "b12": [
            "Gradient-based learning applied to document recognition",
            "",
            "",
            "",
            "Lecun",
            "Bottou",
            "Bengio",
            "Haffner"
        ],
        "b13": [
            "ImageNet classification with deep convolutional neural networks",
            "",
            "",
            "",
            "Krizhevsky",
            "Sutskever",
            "Hinton"
        ],
        "b14": [
            "The pascal visual object classes challenge: A retrospective",
            "",
            "",
            "",
            "Everingham",
            "Eslami",
            "Van Gool",
            "Williams",
            "Winn",
            "Zisserman"
        ],
        "b15": [
            "ImageNet large scale visual recognition challenge",
            "",
            "",
            "",
            "Russakovsky",
            "Deng",
            "Su",
            "Krause",
            "Satheesh",
            "Ma",
            "Huang",
            "Karpathy",
            "Khosla",
            "Bernstein"
        ],
        "b16": [
            "Microsoft COCO: Common objects in context",
            "",
            "",
            "",
            "Lin",
            "Maire",
            "Belongie",
            "Hays",
            "Perona",
            "Ramanan",
            "Doll\u00e1r",
            "Zitnick"
        ],
        "b17": [
            "Region-based convolutional networks for accurate object detection and segmentation",
            "",
            "",
            "",
            "Girshick",
            "Donahue",
            "Darrell",
            "Malik"
        ],
        "b18": [
            "Fast R-CNN",
            "",
            "",
            "",
            "Girshick"
        ],
        "b19": [
            "Faster R-CNN: Towards real-time object detection with region proposal networks",
            "",
            "",
            "",
            "Ren",
            "He",
            "Girshick",
            "Sun"
        ],
        "b20": [
            "You only look once: Unified, real-time object detection",
            "",
            "",
            "",
            "Redmon",
            "Divvala",
            "Girshick",
            "Farhadi"
        ],
        "b21": [
            "SSD: Single shot multibox detector",
            "",
            "",
            "",
            "Liu",
            "Anguelov",
            "Erhan",
            "Szegedy",
            "Reed",
            "Fu",
            "Berg"
        ],
        "b22": [
            "Single-shot object detection with enriched semantics",
            "",
            "",
            "",
            "Zhang",
            "Qiao",
            "Xie",
            "Shen",
            "Wang",
            "Yuille"
        ],
        "b23": [
            "Weakly supervised large scale object localization with multiple instance learning and bag splitting",
            "",
            "",
            "",
            "Ren",
            "Huang",
            "Tao",
            "Tan"
        ],
        "b24": [
            "Weakly supervised object localization with multi-fold multiple instance learning",
            "",
            "",
            "",
            "Cinbis",
            "Verbeek",
            "Schmid"
        ],
        "b25": [
            "Relaxed multiple-instance SVM with application to object discovery",
            "",
            "",
            "",
            "Wang",
            "Zhu",
            "Yao",
            "Bai"
        ],
        "b26": [
            "Weakly supervised object localization using things and stuff transfer",
            "",
            "",
            "",
            "Shi",
            "Caesar",
            "Ferrari"
        ],
        "b27": [
            "Deep patch learning for weakly supervised object classification and discovery",
            "",
            "",
            "",
            "Tang",
            "Wang",
            "Huang",
            "Bai",
            "Liu"
        ],
        "b28": [
            "Weakly supervised deep detection networks",
            "",
            "",
            "",
            "Bilen",
            "Vedaldi"
        ],
        "b29": [
            "ContextLocNet: Context-aware deep network models for weakly supervised localization",
            "",
            "",
            "",
            "Kantorov",
            "Oquab",
            "Cho",
            "Laptev"
        ],
        "b30": [
            "Weakly supervised cascaded convolutional networks",
            "",
            "",
            "",
            "Diba",
            "Sharma",
            "Pazandeh",
            "Pirsiavash",
            "Van Gool"
        ],
        "b31": [
            "Selective search for object recognition",
            "",
            "",
            "",
            "Uijlings",
            "Van De Sande",
            "Gevers",
            "Smeulders"
        ],
        "b32": [
            "Multiple instance detection network with online instance classifier refinement",
            "",
            "",
            "",
            "Tang",
            "Wang",
            "Bai",
            "Liu"
        ],
        "b33": [
            "Solving the multiple instance problem with axis-parallel rectangles",
            "",
            "",
            "",
            "Dietterich",
            "Lathrop",
            "Lozano-P\u00e9rez"
        ],
        "b34": [
            "Support vector machines for multiple-instance learning",
            "",
            "",
            "",
            "Andrews",
            "Tsochantaridis",
            "Hofmann"
        ],
        "b35": [
            "EM-DD: An improved multipleinstance learning technique",
            "",
            "",
            "",
            "Zhang",
            "Goldman"
        ],
        "b36": [
            "Revisiting multiple instance neural networks",
            "",
            "",
            "",
            "Wang",
            "Yan",
            "Tang",
            "Bai",
            "Liu"
        ],
        "b37": [
            "Harvesting mid-level visual concepts from large-scale internet images",
            "",
            "",
            "",
            "Li",
            "Wu",
            "Tu"
        ],
        "b38": [
            "Learning multi-instance deep discriminative patterns for image classification",
            "",
            "",
            "",
            "Tang",
            "Wang",
            "Feng",
            "Liu"
        ],
        "b39": [
            "Fully convolutional multi-class multiple instance learning",
            "",
            "",
            "",
            "Pathak",
            "Shelhamer",
            "Long",
            "Darrell"
        ],
        "b40": [
            "From image-level to pixel-level labeling with convolutional networks",
            "",
            "",
            "",
            "Pinheiro",
            "Collobert"
        ],
        "b41": [
            "Multiple instance boosting for object detection",
            "",
            "",
            "",
            "Zhang",
            "Platt",
            "Viola"
        ],
        "b42": [
            "Robust object tracking with online multiple instance learning",
            "",
            "",
            "",
            "Babenko",
            "Yang",
            "Belongie"
        ],
        "b43": [
            "Is object localization for free?-weakly-supervised learning with convolutional neural networks",
            "",
            "",
            "",
            "Oquab",
            "Bottou",
            "Laptev",
            "Sivic"
        ],
        "b44": [
            "An exemplar model for learning object classes",
            "",
            "",
            "",
            "Chum",
            "Zisserman"
        ],
        "b45": [
            "Weakly supervised localization and learning with generic knowledge",
            "",
            "",
            "",
            "Deselaers",
            "Alexe",
            "Ferrari"
        ],
        "b46": [
            "Scene recognition and weakly supervised object localization with deformable part-based models",
            "",
            "",
            "",
            "Pandey",
            "Lazebnik"
        ],
        "b47": [
            "Bayesian joint modelling for object localisation in weakly labelled images",
            "",
            "",
            "",
            "Shi",
            "Hospedales",
            "Xiang"
        ],
        "b48": [
            "On learning to localize objects with minimal supervision",
            "",
            "",
            "",
            "Song",
            "Girshick",
            "Jegelka",
            "Mairal",
            "Harchaoui",
            "Darrell"
        ],
        "b49": [
            "Weakly-supervised discovery of visual pattern configurations",
            "",
            "",
            "",
            "Song",
            "Lee",
            "Jegelka",
            "Darrell"
        ],
        "b50": [
            "Weakly supervised object detection with convex clustering",
            "",
            "",
            "",
            "Bilen",
            "Pedersoli",
            "Tuytelaars"
        ],
        "b51": [
            "Weakly supervised object localization with latent category learning",
            "",
            "",
            "",
            "Wang",
            "Ren",
            "Huang",
            "Tan"
        ],
        "b52": [
            "Measuring the objectness of image windows",
            "",
            "",
            "",
            "Alexe",
            "Deselaers",
            "Ferrari"
        ],
        "b53": [
            "Object detection with discriminatively trained part-based models",
            "",
            "",
            "",
            "Felzenszwalb",
            "Girshick",
            "Mcallester",
            "Ramanan"
        ],
        "b54": [
            "Deep self-taught learning for weakly supervised object localization",
            "",
            "",
            "",
            "Jie",
            "Wei",
            "Jin",
            "Feng",
            "Liu"
        ],
        "b55": [
            "HCP: A flexible CNN framework for multi-label image classification",
            "",
            "",
            "",
            "Wei",
            "Xia",
            "Lin",
            "Huang",
            "Ni",
            "Dong",
            "Zhao",
            "Yan"
        ],
        "b56": [
            "Spatial pyramid pooling in deep convolutional networks for visual recognition",
            "",
            "",
            "",
            "He",
            "Zhang",
            "Ren",
            "Sun"
        ],
        "b57": [
            "Multitask learning",
            "",
            "",
            "",
            "Caruana"
        ],
        "b58": [
            "Edge boxes: Locating object proposals from edges",
            "",
            "",
            "",
            "Zitnick",
            "Doll\u00e1r"
        ],
        "b59": [
            "Some methods for classification and analysis of multivariate observations",
            "",
            "",
            "",
            "Macqueen"
        ],
        "b60": [
            "Return of the devil in the details: Delving deep into convolutional nets",
            "",
            "",
            "",
            "Chatfield",
            "Simonyan",
            "Vedaldi",
            "Zisserman"
        ],
        "b61": [
            "Very deep convolutional networks for large-scale image recognition",
            "",
            "",
            "",
            "Simonyan",
            "Zisserman"
        ],
        "b62": [
            "Multi-scale context aggregation by dilated convolutions",
            "",
            "",
            "",
            "Yu",
            "Koltun"
        ],
        "b63": [
            "DeepLab: Semantic image segmentation with deep convolutional nets, atrous convolution, and fully connected CRFs",
            "",
            "",
            "",
            "Chen",
            "Papandreou",
            "Kokkinos",
            "Murphy",
            "Yuille"
        ],
        "b64": [
            "Multiscale combinatorial grouping for image segmentation and object proposal generation",
            "",
            "",
            "",
            "Pont-Tuset",
            "Arbelaez",
            "Barron",
            "Marques",
            "Malik"
        ],
        "b65": [
            "",
            "",
            "Weakly supervised object localization with progressive domain adaptation",
            ""
        ]
    },
    {
        "tab_0": "5 , 1 \u2026 \ud835\udc65 7 , 1 , \ud835\udc65 8 , 1 \u2026 \ud835\udc65 10 , 2 , \ud835\udc65 11 , 2 \u2026 }\ud835\udc65 4\ud835\udc65 1 \ud835\udc65 2\ud835\udc65 11\ud835\udc65 10\ud835\udc4b 2\ud835\udc4b 1\ud835\udc4b 4\ud835\udc65 5\ud835\udc65 7\ud835\udc65 8\ud835\udc4b 3{ \ud835\udc4b 1 , 0 ,\ud835\udc4b 2 , 1 ,\ud835\udc4b 3 , 1 ,\ud835\udc4b 4 , 2 }Object DetectorObject Detector(b)(c)",
        "tab_1": "TABLE 11Results (AP in %)  for different methods on the VOC 2007 test set. The upper part shows the results using a single model. The lower part shows the results of combing multiple models. See Section 4.3 for the definitions of the PCL-based methods.Methodaero bike bird boat bottle buscarcat chair cow table dog horse mbike person plant sheep sofa train tvmAPWSDDN-VGG F [17]",
        "tab_3": "TABLE 55Results (mAP in %)  for different methods on the ImageNet dataset. See Section 4.3 for the definitions of the PCL-based methods.MethodResultsRen et al. [12]9.6Li et al. [54]10.8WCCN [19]16.3PCL-OB-G-VGG M14.4PCL-OB-G-VGG1618.4PCL-OB-G-Ens.18.8PCL-OB-G-Ens.+FRCNN19.6",
        "tab_4": "TABLE 66Results  (mAP@0.5 and mAP@[.5, .95] in %) of different methods on the MS-COCO dataset. See Section 4.3 for the definitions of the PCL-based methods.MethodmAP@0.5mAP@[.5, .95]Ge et al. [57]19.38.9PCL-OB-G-VGG M16.67.3PCL-OB-G-VGG1619.48.5PCL-OB-G-Ens.19.58.6PCL-OB-G-Ens.+FRCNN19.69.2",
        "tab_5": "TABLE 77Runtime comparisons between our method (\"PCL\" in table) and our basic MIL network[17] (\"Basic\" in table). share the same proposal feature computations. The small extra training computations of our method mainly come from the procedures to find proposal cluster centers and generate proposal clusters. Although with small extra training computations, our method obtains much better detection results than the basic MIL network.PCLBasicVGG M VGG16VGG M VGG16Training (second/iteration)1.111.510.991.40Testing (second/image)0.711.220.711.21streams"
    }
]